i<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Universal Language Flashcards v3.1 - Cloud Sync</title>
    <link rel="icon" type="image/svg+xml" href="favicon.svg?v=2.4.1">
    <link rel="alternate icon" href="favicon.ico?v=2.4.1">
    <link rel="shortcut icon" href="favicon.ico?v=2.4.1">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 20px;
            overflow-y: auto;
        }

        .container {
            width: 100%;
            max-width: 600px;
            background: white;
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            margin-top: 20px;
            margin-bottom: 40px;
        }

        h1 {
            text-align: center;
            color: #667eea;
            margin-bottom: 30px;
            font-size: 2em;
        }

        .upload-section {
            margin-bottom: 30px;
            text-align: center;
        }

        .upload-label {
            display: inline-block;
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border-radius: 10px;
            cursor: pointer;
            transition: background 0.3s;
            font-weight: 600;
        }

        .upload-label:hover {
            background: #5568d3;
        }

        #csvFile {
            display: none;
        }

        .file-info {
            margin-top: 10px;
            color: #666;
            font-size: 0.9em;
            line-height: 1.6;
        }

        .file-info strong {
            color: #667eea;
            font-size: 1.1em;
        }

        .flashcard-container {
            display: none;
            margin-bottom: 30px;
        }

        .flashcard {
            position: relative;
            width: 100%;
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .card-source-section {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 25px 20px;
            text-align: center;
            position: relative;
        }

        .card-label {
            font-size: 0.7em;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 10px;
            opacity: 0.9;
        }

        .card-content {
            font-size: 2em;
            font-weight: 700;
            text-align: center;
            word-wrap: break-word;
            margin: 12px 0;
        }

        .card-divider {
            border: none;
            border-top: 2px dashed rgba(255, 255, 255, 0.3);
            margin: 12px 0;
        }

        .card-target-section {
            background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
            color: white;
            padding: 20px;
            text-align: center;
            max-height: 0;
            opacity: 0;
            overflow: hidden;
            transition: all 0.4s ease-in-out;
        }

        .card-target-section.revealed {
            max-height: 250px;
            opacity: 1;
            padding: 25px 20px;
        }

        .reveal-btn {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            cursor: pointer;
            font-size: 0.85em;
            font-weight: 600;
            transition: all 0.3s;
            margin-top: 8px;
        }

        .reveal-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .card-detail {
            font-size: 0.9em;
            margin-top: 15px;
            opacity: 0.9;
            font-style: italic;
            text-align: center;
        }

        .navigation {
            display: none;
            justify-content: space-between;
            align-items: center;
            margin-top: 20px;
        }

        .nav-button {
            padding: 12px 30px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-size: 1em;
            font-weight: 600;
            transition: background 0.3s;
        }

        .nav-button:hover:not(:disabled) {
            background: #5568d3;
        }

        .nav-button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }

        .progress {
            text-align: center;
            color: #667eea;
            font-weight: 600;
            font-size: 1.1em;
        }

        .hint {
            text-align: center;
            color: #999;
            font-size: 0.9em;
            margin-top: 10px;
        }

        .show-meanings-toggle {
            display: none;
            align-items: center;
            justify-content: center;
            gap: 10px;
            margin: 15px 0;
            padding: 12px;
            background: #f0f9ff;
            border-radius: 10px;
        }

        .show-meanings-toggle label {
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            font-weight: 600;
            color: #667eea;
            user-select: none;
        }

        .show-meanings-toggle input[type="checkbox"] {
            width: 20px;
            height: 20px;
            cursor: pointer;
            accent-color: #667eea;
        }

        .control-buttons {
            display: none;
            flex-wrap: wrap;
            gap: 10px;
            justify-content: center;
            margin: 20px 0;
        }

        .control-btn {
            padding: 10px 20px;
            background: #10b981;
            color: white;
            border: none;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: background 0.3s;
        }

        .control-btn:hover {
            background: #059669;
        }

        .control-btn.active {
            background: #f59e0b;
        }

        .autoplay-btn {
            background: #8b5cf6;
        }

        .autoplay-btn:hover {
            background: #7c3aed;
        }

        .autoplay-btn.playing {
            background: #ef4444;
            animation: pulse 1.5s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }

        .autoplay-settings {
            display: none;
            background: #f9fafb;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #e5e7eb;
        }

        .category-manager {
            display: none;
            background: #fef3c7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #f59e0b;
        }

        .category-manager h4 {
            margin: 0 0 10px 0;
            color: #d97706;
        }

        .category-section {
            margin: 10px 0;
        }

        .category-input-group {
            display: flex;
            gap: 8px;
            margin: 8px 0;
        }

        .category-input-group input,
        .category-input-group select {
            padding: 6px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            font-size: 0.9em;
        }

        .category-input-group button {
            padding: 6px 15px;
            background: #f59e0b;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
        }

        .category-input-group button:hover {
            background: #d97706;
        }

        .category-list {
            background: white;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            padding: 10px;
            margin: 10px 0;
            max-height: 200px;
            overflow-y: auto;
        }

        .category-item {
            padding: 8px;
            margin: 4px 0;
            background: #fffbeb;
            border-radius: 4px;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .category-item:hover {
            background: #fef3c7;
        }

        .subcategory-item {
            margin-left: 20px;
            padding: 6px;
            font-size: 0.9em;
            background: #fefce8;
        }

        .category-badge {
            display: inline-block;
            padding: 2px 8px;
            background: #fbbf24;
            color: #78350f;
            border-radius: 12px;
            font-size: 0.8em;
            font-weight: 600;
        }

        .btn-small {
            padding: 3px 8px;
            font-size: 0.8em;
            margin-left: 5px;
        }

        .advanced-settings {
            display: none;
            background: #dbeafe;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #3b82f6;
        }

        .advanced-settings h4 {
            margin: 0 0 10px 0;
            color: #1e40af;
        }

        .timer-display {
            background: #fee2e2;
            padding: 10px;
            border-radius: 8px;
            text-align: center;
            margin: 10px 0;
            font-size: 1.2em;
            font-weight: bold;
            color: #991b1b;
            display: none;
        }

        .session-stats {
            background: #d1fae5;
            padding: 0;
            border-radius: 10px;
            margin: 15px 0;
            display: none;
            overflow: hidden;
            border: 2px solid #10b981;
        }

        .session-stats-header {
            padding: 12px 15px;
            background: #10b981;
            color: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            user-select: none;
            transition: background 0.3s;
        }

        .session-stats-header:hover {
            background: #059669;
        }

        .session-stats-header h4 {
            margin: 0;
            font-size: 1em;
        }

        .session-stats-toggle {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .session-stats-toggle.collapsed {
            transform: rotate(-90deg);
        }

        .session-stats-content {
            padding: 15px;
            max-height: 300px;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.3s ease-out;
        }

        .session-stats-content.collapsed {
            max-height: 0;
            padding: 0 15px;
        }

        .stat-row {
            display: flex;
            justify-content: space-between;
            padding: 5px 0;
            border-bottom: 1px solid #a7f3d0;
        }

        .stat-label {
            color: #047857;
            font-weight: 600;
        }

        .stat-value {
            color: #065f46;
            font-weight: bold;
        }

        .focus-mode {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: #1f2937;
            z-index: 9999;
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .focus-mode .container {
            background: #374151;
            max-width: 800px;
        }

        .focus-mode .flashcard {
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
        }

        .focus-exit-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-weight: 600;
            z-index: 10000;
        }

        .focus-exit-btn:hover {
            background: #dc2626;
        }

        .autoplay-settings label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 8px 0;
            font-size: 0.9em;
            color: #374151;
        }

        .voice-settings {
            display: none;
            background: #fef3c7;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            border: 2px solid #fbbf24;
        }

        .voice-settings h4 {
            margin: 0 0 10px 0;
            color: #d97706;
        }

        .voice-settings label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.9em;
            color: #92400e;
        }

        .voice-settings select {
            flex: 1;
            padding: 6px 10px;
            border: 2px solid #fbbf24;
            border-radius: 6px;
            background: white;
            font-size: 0.9em;
            cursor: pointer;
        }

        .voice-settings input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: #f59e0b;
        }

        .autoplay-settings input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
            accent-color: #8b5cf6;
        }

        .autoplay-settings input[type="range"] {
            flex: 1;
            cursor: pointer;
            accent-color: #8b5cf6;
        }

        .delay-value {
            font-weight: 600;
            color: #8b5cf6;
            min-width: 50px;
            text-align: right;
        }

        .learned-badge {
            position: absolute;
            top: 10px;
            right: 10px;
            background: #10b981;
            color: white;
            padding: 5px 15px;
            border-radius: 20px;
            font-size: 0.8em;
            font-weight: 600;
            z-index: 10;
        }

        .stats {
            display: none;
            background: #f0f9ff;
            padding: 15px;
            border-radius: 10px;
            margin: 15px 0;
            text-align: center;
        }

        .stats-item {
            display: inline-block;
            margin: 0 15px;
            color: #667eea;
            font-weight: 600;
        }

        .stats-value {
            font-size: 1.5em;
            display: block;
        }

        .audio-btn {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            z-index: 10;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-btn:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .audio-btn-english {
            position: relative;
            top: auto;
            left: auto;
            margin: 15px auto 0 auto;
            background: rgba(255, 255, 255, 0.3);
            border: 2px solid rgba(255, 255, 255, 0.5);
            color: white;
            width: 50px;
            height: 50px;
            border-radius: 50%;
            font-size: 1.5em;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .audio-btn-english:hover {
            background: rgba(255, 255, 255, 0.5);
            transform: scale(1.1);
        }

        .review-info {
            font-size: 0.75em;
            color: rgba(255, 255, 255, 0.8);
            margin-top: 10px;
            text-align: center;
        }

        .format-selector {
            background: #f8fafc;
            padding: 25px;
            border-radius: 15px;
            margin: 20px 0;
            border: 3px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }

        .format-selector h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .format-option {
            transition: all 0.3s;
        }

        .format-option:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.15);
        }

        .format-preset-btn {
            padding: 15px;
            background: white;
            border: 2px solid #0284c7;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
            font-size: 0.9em;
        }

        .format-preset-btn:hover {
            background: #0284c7;
            color: white;
            transform: scale(1.05);
        }

        .format-preset-btn strong {
            display: block;
            margin-bottom: 8px;
        }

        .column-mapper {
            background: #f0f9ff;
            padding: 20px;
            border-radius: 15px;
            margin: 20px 0;
            border: 3px solid #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
            overflow: visible;
        }

        .column-mapper h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .column-mapper p {
            color: #666;
            font-size: 0.95em;
        }

        #dataPreviewTable {
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
        }

        #dataPreviewTable th {
            padding: 18px 12px;
            text-align: center;
            font-weight: 600;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.3s;
            position: relative;
            user-select: none;
            border: 4px solid #e5e7eb;
            background: #f9fafb;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.05);
        }

        #dataPreviewTable th:hover {
            background: #fef3c7;
            border-color: #fbbf24;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #dataPreviewTable th::before {
            content: 'üëÜ Click to Select Type';
            display: block;
            font-size: 0.7em;
            font-weight: normal;
            color: #f59e0b;
            margin-bottom: 5px;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-3px); }
        }

        #dataPreviewTable th.selected {
            background: #667eea;
            color: white;
            border: 4px solid #667eea;
        }

        #dataPreviewTable th.type-source {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: 4px solid #10b981;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.4);
        }

        #dataPreviewTable th.type-source::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-sourceExtended {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            border: 4px solid #f59e0b;
            box-shadow: 0 4px 12px rgba(245, 158, 11, 0.4);
        }

        #dataPreviewTable th.type-sourceExtended::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-target {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
            color: white;
            border: 4px solid #3b82f6;
            box-shadow: 0 4px 12px rgba(59, 130, 246, 0.4);
        }

        #dataPreviewTable th.type-target::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-targetExtended {
            background: linear-gradient(135deg, #ec4899 0%, #db2777 100%);
            color: white;
            border: 4px solid #ec4899;
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.4);
        }

        #dataPreviewTable th.type-targetExtended::before {
            content: '‚úì Selected';
            color: white;
            animation: none;
        }

        #dataPreviewTable th.type-ignore {
            background: #94a3b8;
            color: white;
            border: 4px solid #94a3b8;
            opacity: 0.5;
        }

        #dataPreviewTable th.type-ignore::before {
            content: '‚úó Ignored';
            color: white;
            animation: none;
        }

        #dataPreviewTable td {
            padding: 10px 12px;
            border-bottom: 1px solid #e5e7eb;
            max-width: 250px;
            overflow: hidden;
            text-overflow: ellipsis;
            white-space: nowrap;
        }

        #dataPreviewTable tr:last-child td {
            border-bottom: none;
        }

        #dataPreviewTable tr:nth-child(even) {
            background: #f9fafb;
        }

        .column-type-selector {
            position: fixed;
            background: white;
            border: 4px solid #667eea;
            border-radius: 12px;
            padding: 12px;
            z-index: 10000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            width: 280px;
            max-height: 350px;
            overflow-y: auto;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .column-type-selector.active {
            animation: slideDown 0.2s ease-out;
        }

        .column-type-selector::-webkit-scrollbar {
            width: 8px;
        }

        .column-type-selector::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .column-type-selector::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .column-type-selector::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .type-option {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid transparent;
        }

        .type-option small {
            display: block;
            font-size: 0.8em;
            line-height: 1.2;
        }

        .type-option:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .type-option:active {
            transform: translateX(0);
        }

        .type-option[style*="color: #10b981"]:hover {
            background: #d1fae5;
            border-color: #10b981;
        }

        .type-option[style*="color: #f59e0b"]:hover {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .type-option[style*="color: #3b82f6"]:hover {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .type-option[style*="color: #ec4899"]:hover {
            background: #fce7f3;
            border-color: #ec4899;
        }

        .type-option[style*="color: #94a3b8"]:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        .instructions {
            background: #f7f7f7;
            padding: 20px;
            border-radius: 10px;
            margin-bottom: 20px;
            font-size: 0.9em;
            color: #666;
        }

        .instructions h3 {
            color: #667eea;
            margin-bottom: 10px;
        }

        .instructions code {
            background: #e0e0e0;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: monospace;
        }

        /* Practice Mode Styles */
        .practice-mode-btn {
            display: none;
            width: 100%;
            padding: 18px;
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
            color: white;
            border: none;
            border-radius: 12px;
            cursor: pointer;
            font-size: 1.2em;
            font-weight: 700;
            margin: 20px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(16, 185, 129, 0.3);
        }

        .practice-mode-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(16, 185, 129, 0.4);
        }

        .practice-mode-btn.active {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            animation: pulse-practice 2s infinite;
        }

        @keyframes pulse-practice {
            0%, 100% { box-shadow: 0 4px 12px rgba(239, 68, 68, 0.3); }
            50% { box-shadow: 0 4px 20px rgba(239, 68, 68, 0.6); }
        }

        body.practice-mode {
            align-items: center;
            padding: 10px;
        }

        body.practice-mode .container {
            margin-top: 0;
            max-width: 700px;
        }

        body.practice-mode .upload-section,
        body.practice-mode .category-browser,
        body.practice-mode .category-section,
        body.practice-mode .settings-menu,
        body.practice-mode .format-selector,
        body.practice-mode .column-mapper,
        body.practice-mode .file-info,
        body.practice-mode .category-manager,
        body.practice-mode h1,
        body.practice-mode .settings-toggle-btn,
        body.practice-mode #categoryMgmtToggleBtn,
        body.practice-mode #testAutoOpenBtn,
        body.practice-mode .language-selector {
            display: none !important;
        }

        body.practice-mode .flashcard-container {
            margin-bottom: 20px;
        }

        body.practice-mode .flashcard {
            transform: scale(1.05);
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.2);
        }

        .practice-mode-controls {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            gap: 10px;
        }

        body.practice-mode .practice-mode-controls {
            display: flex;
        }

        .floating-control-btn {
            padding: 12px 24px;
            background: rgba(255, 255, 255, 0.95);
            border: 2px solid #667eea;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        }

        .floating-control-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .floating-control-btn.stop {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
            border-color: #dc2626;
        }

        /* Settings Menu Styles */
        .settings-menu {
            display: none;
            background: #f8fafc;
            border-radius: 15px;
            padding: 15px;
            margin: 20px 0;
            border: 2px solid #e2e8f0;
            max-height: 400px;
            overflow-y: auto;
            overflow-x: hidden;
            scroll-behavior: smooth;
            position: relative;
        }

        .settings-menu::-webkit-scrollbar {
            width: 10px;
        }

        .settings-menu::-webkit-scrollbar-track {
            background: #e2e8f0;
            border-radius: 10px;
        }

        .settings-menu::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 10px;
        }

        .settings-menu::-webkit-scrollbar-thumb:hover {
            background: #5568d3;
        }

        .settings-toggle-btn {
            width: 100%;
            padding: 15px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 12px;
            font-size: 1.1em;
            font-weight: 600;
            cursor: pointer;
            display: none;
            align-items: center;
            justify-content: space-between;
            margin: 15px 0;
            transition: all 0.3s;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .settings-toggle-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(0, 0, 0, 0.15);
        }

        .settings-toggle-btn.active {
            background: linear-gradient(135deg, #764ba2 0%, #667eea 100%);
        }

        .toggle-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .settings-toggle-btn.active .toggle-icon {
            transform: rotate(180deg);
        }

        .accordion-item {
            background: white;
            border-radius: 10px;
            margin: 10px 0;
            overflow: hidden;
            border: 2px solid #e2e8f0;
            transition: all 0.3s;
        }

        .accordion-item:hover {
            border-color: #cbd5e1;
        }

        .accordion-header {
            padding: 15px 20px;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-weight: 600;
            color: #334155;
            user-select: none;
            transition: all 0.3s;
        }

        .accordion-header:hover {
            background: linear-gradient(135deg, #e2e8f0 0%, #cbd5e1 100%);
        }

        .accordion-header.active {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .accordion-icon {
            font-size: 1.2em;
            transition: transform 0.3s;
        }

        .accordion-header.active .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.4s ease-out, padding 0.4s ease-out;
            padding: 0 20px;
        }

        .accordion-content.active {
            max-height: 2000px;
            padding: 20px;
            transition: max-height 0.5s ease-in, padding 0.4s ease-in;
        }

        .quick-actions {
            display: none;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 8px;
            margin: 12px 0;
        }

        .quick-action-btn {
            padding: 8px 12px;
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            border-radius: 8px;
            font-weight: 600;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 0.9em;
        }

        .quick-action-btn:hover {
            background: #667eea;
            color: white;
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(102, 126, 234, 0.3);
        }

        .quick-action-btn.active {
            background: #667eea;
            color: white;
        }

        /* Fix accordion content labels */
        .accordion-content label {
            display: flex;
            align-items: center;
            gap: 10px;
            margin: 10px 0;
            font-size: 0.95em;
            color: #334155;
        }

        .accordion-content label span {
            flex: 1;
        }

        .accordion-content label select,
        .accordion-content label input[type="range"] {
            flex: 2;
        }

        /* Modal Popup Styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeIn 0.3s ease-out;
            overflow-y: auto;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal-content {
            background: white;
            border-radius: 20px;
            padding: 30px;
            max-width: 600px;
            width: 90%;
            max-height: 80vh;
            overflow-y: auto;
            overflow-x: visible;
            box-shadow: 0 25px 50px rgba(0, 0, 0, 0.5);
            animation: slideUp 0.3s ease-out;
            position: relative;
        }

        @keyframes slideUp {
            from {
                opacity: 0;
                transform: translateY(50px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            padding-bottom: 15px;
            border-bottom: 3px solid #667eea;
        }

        .modal-header h3 {
            margin: 0;
            color: #667eea;
            font-size: 1.5em;
        }

        .modal-close {
            background: #ef4444;
            color: white;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 1.2em;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s;
            font-weight: bold;
        }

        .modal-close:hover {
            background: #dc2626;
            transform: scale(1.1);
        }

        .modal-body {
            padding: 10px 0;
            padding-bottom: 450px;
        }

        .modal-body > p {
            color: #666;
            margin-bottom: 20px;
            font-size: 0.95em;
        }

        .type-choice-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 20px;
        }

        .type-choice-card {
            background: linear-gradient(135deg, #f8fafc 0%, #f1f5f9 100%);
            border: 3px solid #e2e8f0;
            border-radius: 12px;
            padding: 20px;
            cursor: pointer;
            transition: all 0.3s;
            text-align: center;
        }

        .type-choice-card:hover {
            transform: translateY(-5px);
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);
        }

        .type-choice-card[data-type="source"]:hover {
            border-color: #10b981;
            background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%);
        }

        .type-choice-card[data-type="sourceExtended"]:hover {
            border-color: #f59e0b;
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
        }

        .type-choice-card[data-type="target"]:hover {
            border-color: #3b82f6;
            background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%);
        }

        .type-choice-card[data-type="targetExtended"]:hover {
            border-color: #ec4899;
            background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%);
        }

        .type-choice-card[data-type="ignore"]:hover {
            border-color: #94a3b8;
            background: linear-gradient(135deg, #f1f5f9 0%, #e2e8f0 100%);
        }

        .type-icon {
            font-size: 3em;
            margin-bottom: 10px;
        }

        .type-name {
            font-size: 1.1em;
            font-weight: 600;
            color: #334155;
            margin-bottom: 8px;
        }

        .type-desc {
            font-size: 0.85em;
            color: #64748b;
            line-height: 1.4;
        }

        /* Dropdown Selector Styles (inside modal) */
        .column-type-selector {
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            margin-top: 5px;
            background: white;
            border: 4px solid #667eea;
            border-radius: 12px;
            padding: 12px;
            z-index: 20000;
            box-shadow: 0 8px 24px rgba(0, 0, 0, 0.3);
            display: none;
            width: 280px;
            max-height: 400px;
            overflow-y: auto;
        }

        .column-type-selector.active {
            display: block !important;
        }

        .column-type-selector::-webkit-scrollbar {
            width: 8px;
        }

        .column-type-selector::-webkit-scrollbar-track {
            background: #f1f5f9;
            border-radius: 4px;
        }

        .column-type-selector::-webkit-scrollbar-thumb {
            background: #667eea;
            border-radius: 4px;
        }

        .type-option {
            padding: 10px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.85em;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
            border: 2px solid transparent;
        }

        .type-option small {
            display: block;
            font-size: 0.8em;
            line-height: 1.2;
        }

        .type-option:hover {
            transform: translateX(2px);
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
        }

        .type-option[style*="color: #10b981"]:hover {
            background: #d1fae5;
            border-color: #10b981;
        }

        .type-option[style*="color: #f59e0b"]:hover {
            background: #fef3c7;
            border-color: #f59e0b;
        }

        .type-option[style*="color: #3b82f6"]:hover {
            background: #dbeafe;
            border-color: #3b82f6;
        }

        .type-option[style*="color: #ec4899"]:hover {
            background: #fce7f3;
            border-color: #ec4899;
        }

        .type-option[style*="color: #94a3b8"]:hover {
            background: #f1f5f9;
            border-color: #94a3b8;
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .card-source-section {
                padding: 20px 15px;
            }

            .card-target-section.revealed {
                padding: 20px 15px;
                max-height: 300px;
            }

            .card-content {
                font-size: 1.8em;
            }

            .practice-mode-controls {
                top: 10px;
                right: 10px;
                flex-direction: column;
            }

            .floating-control-btn {
                padding: 10px 18px;
                font-size: 0.9em;
            }
        }

        @media (max-width: 480px) {
            .container {
                padding: 15px;
            }

            h1 {
                font-size: 1.3em;
            }

            .card-source-section {
                padding: 18px 12px;
            }

            .card-target-section.revealed {
                padding: 18px 12px;
                max-height: 280px;
            }

            .card-content {
                font-size: 1.5em;
            }

            .card-label {
                font-size: 0.65em;
            }

            .reveal-btn {
                padding: 7px 15px;
                font-size: 0.8em;
            }

            .nav-button {
                padding: 10px 15px;
                font-size: 0.85em;
            }

            .audio-btn, .audio-btn-target {
                width: 40px;
                height: 40px;
                font-size: 1.2em;
            }

            body.practice-mode .container {
                max-width: 100%;
            }

            .practice-mode-controls {
                top: 5px;
                right: 5px;
                gap: 5px;
            }

            .floating-control-btn {
                padding: 8px 12px;
                font-size: 0.8em;
            }

            .practice-mode-btn {
                padding: 15px;
                font-size: 1em;
            }

            /* Modal responsive adjustments */
            .modal-content {
                width: 95%;
                padding: 20px;
            }

            .type-choice-grid {
                grid-template-columns: 1fr;
                gap: 10px;
            }

            .type-choice-card {
                padding: 15px;
            }

            .type-icon {
                font-size: 2.5em;
            }

            .modal-header h3 {
                font-size: 1.2em;
            }
        }

        /* Cloud Sync Login Modal */
        .login-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
        }

        .login-box {
            background: white;
            padding: 40px;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 400px;
            width: 90%;
        }

        .login-box h2 {
            color: #667eea;
            text-align: center;
            margin-bottom: 10px;
        }

        .login-box p {
            text-align: center;
            color: #666;
            font-size: 0.9em;
            margin-bottom: 30px;
        }

        .login-input {
            width: 100%;
            padding: 12px;
            margin-bottom: 15px;
            border: 2px solid #667eea;
            border-radius: 8px;
            font-size: 1em;
        }

        .login-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1.1em;
            font-weight: bold;
            cursor: pointer;
            margin-bottom: 10px;
        }

        .login-btn:hover {
            opacity: 0.9;
        }

        .skip-btn {
            width: 100%;
            padding: 10px;
            background: #94a3b8;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 0.9em;
            cursor: pointer;
        }

        .skip-btn:hover {
            background: #64748b;
        }

        .login-info {
            background: #f0f9ff;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            font-size: 0.85em;
            color: #555;
        }

        .sync-status {
            position: fixed;
            top: 20px;
            right: 20px;
            background: white;
            padding: 10px 20px;
            border-radius: 10px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            font-size: 0.9em;
            z-index: 1000;
        }

        .sync-status.synced {
            color: #10b981;
            border-left: 4px solid #10b981;
        }

        .account-button {
            position: fixed;
            top: 20px;
            right: 180px;
            z-index: 1000;
        }

        .account-button button:hover {
            background: #5568d3 !important;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4) !important;
        }

        .sync-status.syncing {
            color: #f59e0b;
            border-left: 4px solid #f59e0b;
        }

        .sync-status.error {
            color: #ef4444;
            border-left: 4px solid #ef4444;
        }
    </style>

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>

    <!-- CryptoJS for encryption -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
</head>
<body>
    <!-- Cloud Sync Login Modal -->
    <div class="login-overlay" id="loginOverlay">
        <div class="login-box">
            <h2 id="loginTitle">‚òÅÔ∏è Cloud Sync Login</h2>
            <p id="loginSubtitle">Access your categories from any device</p>

            <div class="login-info">
                <strong>üîê Secure & Private:</strong><br>
                ‚Ä¢ Your data is encrypted with your password<br>
                ‚Ä¢ Categories sync across all your devices<br>
                ‚Ä¢ No email required, just username + password
            </div>

            <input type="text" id="username" class="login-input" placeholder="Username" autocomplete="username">
            <input type="password" id="password" class="login-input" placeholder="Password" autocomplete="current-password">
            <input type="password" id="confirmPassword" class="login-input" placeholder="Confirm Password" autocomplete="new-password" style="display: none;">

            <button class="login-btn" id="loginBtn" onclick="window.cloudLogin()">üîì Login</button>
            <button class="login-btn" id="signupBtn" onclick="window.cloudSignup()" style="display: none;">üìù Sign Up</button>

            <div style="text-align: center; margin: 10px 0; color: #666; font-size: 0.9em;">
                <span id="toggleText">Don't have an account? <a href="#" onclick="window.toggleLoginMode(); return false;" style="color: #667eea; text-decoration: none; font-weight: bold;">Sign Up</a></span>
            </div>

            <button class="skip-btn" onclick="window.skipLogin()">Skip (Use Local Only)</button>
        </div>
    </div>

    <!-- Sync Status Indicator -->
    <div class="sync-status" id="syncStatus" style="display: none;">
        <span id="syncStatusText">‚òÅÔ∏è Synced</span>
    </div>

    <!-- Account Button (Shows when logged in) -->
    <div class="account-button" id="accountButton" style="display: none;">
        <button onclick="window.openAccountSettings()" style="background: #667eea; color: white; border: none; padding: 10px 20px; border-radius: 10px; cursor: pointer; font-weight: bold; box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);">
            üë§ Account
        </button>
    </div>

    <!-- Account Management Modal -->
    <div class="login-overlay" id="accountModal" style="display: none;">
        <div class="login-box" style="max-width: 500px;">
            <h2 style="color: #667eea; margin-bottom: 20px;">üë§ Account Management</h2>

            <div style="background: #f0f9ff; padding: 15px; border-radius: 10px; margin-bottom: 20px;">
                <p style="margin: 5px 0;"><strong>Username:</strong> <span id="accountUsername">-</span></p>
                <p style="margin: 5px 0;"><strong>Status:</strong> <span id="accountStatus" style="color: #10b981;">‚úÖ Connected</span></p>
                <p style="margin: 5px 0;"><strong>Sync:</strong> <span id="accountSyncStatus">‚òÅÔ∏è Synced</span></p>
            </div>

            <div style="margin: 20px 0;">
                <button onclick="window.showChangePassword()" style="width: 100%; padding: 12px; background: #667eea; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin: 5px 0; font-weight: 600;">
                    üîë Change Password
                </button>
                <button onclick="window.logoutAccount()" style="width: 100%; padding: 12px; background: #f59e0b; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin: 5px 0; font-weight: 600;">
                    üö™ Logout
                </button>
                <button onclick="window.showDeleteAccount()" style="width: 100%; padding: 12px; background: #ef4444; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin: 5px 0; font-weight: 600;">
                    üóëÔ∏è Delete Account
                </button>
            </div>

            <div id="changePasswordSection" style="display: none; background: #fef3c7; padding: 15px; border-radius: 10px; margin: 15px 0;">
                <h3 style="color: #92400e; margin-bottom: 10px;">Change Password</h3>
                <input type="password" id="currentPassword" placeholder="Current Password" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #fbbf24; border-radius: 5px;">
                <input type="password" id="newPassword" placeholder="New Password" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #fbbf24; border-radius: 5px;">
                <input type="password" id="confirmNewPassword" placeholder="Confirm New Password" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #fbbf24; border-radius: 5px;">
                <button onclick="window.changePassword()" style="width: 100%; padding: 10px; background: #10b981; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px; font-weight: 600;">
                    ‚úÖ Confirm Change
                </button>
                <button onclick="window.cancelChangePassword()" style="width: 100%; padding: 10px; background: #6b7280; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 5px;">
                    Cancel
                </button>
            </div>

            <div id="deleteAccountSection" style="display: none; background: #fee2e2; padding: 15px; border-radius: 10px; margin: 15px 0;">
                <h3 style="color: #991b1b; margin-bottom: 10px;">‚ö†Ô∏è Delete Account</h3>
                <p style="color: #991b1b; margin-bottom: 10px;">This will permanently delete all your data from the cloud. This action cannot be undone!</p>
                <input type="password" id="deletePassword" placeholder="Enter Password to Confirm" style="width: 100%; padding: 10px; margin: 5px 0; border: 2px solid #ef4444; border-radius: 5px;">
                <button onclick="window.confirmDeleteAccount()" style="width: 100%; padding: 10px; background: #ef4444; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 10px; font-weight: 600;">
                    üóëÔ∏è Yes, Delete My Account
                </button>
                <button onclick="window.cancelDeleteAccount()" style="width: 100%; padding: 10px; background: #6b7280; color: white; border: none; border-radius: 5px; cursor: pointer; margin-top: 5px;">
                    Cancel
                </button>
            </div>

            <button onclick="window.closeAccountSettings()" style="width: 100%; padding: 12px; background: #6b7280; color: white; border: none; border-radius: 8px; font-size: 14px; cursor: pointer; margin-top: 10px; font-weight: 600;">
                Close
            </button>
        </div>
    </div>

    <div class="container">
        <h1>üåç Universal Language Flashcards <span style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 3px 12px; border-radius: 15px; font-size: 0.7em; vertical-align: middle;">v3.0</span></h1>

        <!-- Category Browser (Always Visible) - Practice existing vocabulary -->
        <div class="category-browser" id="categoryBrowser" style="background: #f0f9ff; padding: 20px; border-radius: 15px; margin-bottom: 20px; border: 3px solid #667eea;">
            <h3 style="color: #667eea; margin-bottom: 15px;">üìö Your Vocabulary Categories</h3>
            <p style="color: #666; font-size: 0.9em; margin-bottom: 15px;">Browse and practice your saved vocabulary organized by categories</p>
            <div id="categoryBrowserList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">
                <!-- Will be populated dynamically -->
            </div>
            <div id="noCategoriesMessage" style="text-align: center; color: #999; padding: 20px; display: none;">
                No categories yet. Upload a file to get started!
            </div>
        </div>

        <!-- Upload Section (Always Visible) -->
        <div class="upload-section">
            <label for="csvFile" class="upload-label">
                üìÅ Choose Vocabulary File
            </label>
            <input type="file" id="csvFile" accept="*">
            <div class="file-info" id="fileInfo"></div>
            <button class="upload-label" id="clearFileBtn" style="background: #ef4444; display: none; margin-top: 10px;">
                üóëÔ∏è Remove Current File
            </button>
        </div>

        <!-- Category Suggestion Box (Always visible when suggestion exists) -->
        <div class="category-section" id="suggestedCategorySection" style="display: none; background: #fef3c7; padding: 20px; border-radius: 12px; margin: 20px 0; border: 3px solid #f59e0b; box-shadow: 0 6px 12px rgba(245, 158, 11, 0.3);">
            <strong style="color: #92400e; font-size: 1.2em; display: block; margin-bottom: 10px;">üí° Suggested Categories</strong>
            <p style="color: #78350f; font-size: 0.95em; margin: 0 0 15px 0;">Based on your filename and content analysis:</p>

            <div style="background: white; padding: 15px; border-radius: 10px; margin-bottom: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <div style="margin-bottom: 12px;">
                    <label style="display: block; color: #92400e; font-weight: 600; margin-bottom: 6px;">üìÅ Category:</label>
                    <input type="text" id="suggestedCategoryInput" style="width: 100%; padding: 10px; border: 2px solid #fbbf24; border-radius: 8px; font-size: 1em;">
                </div>
                <div>
                    <label style="display: block; color: #92400e; font-weight: 600; margin-bottom: 6px;">üìã Subcategory (optional):</label>
                    <input type="text" id="suggestedSubcategoryInput" style="width: 100%; padding: 10px; border: 2px solid #fbbf24; border-radius: 8px; font-size: 1em;">
                    <small style="color: #78350f; font-style: italic; display: block; margin-top: 5px;">Leave empty if no subcategory needed</small>
                </div>
            </div>

            <div style="display: flex; gap: 12px;">
                <button onclick="applySuggestedCategory()" style="flex: 1; padding: 12px 18px; background: #10b981; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.2s;">
                    ‚úì Accept & Apply
                </button>
                <button onclick="rejectSuggestion()" style="flex: 1; padding: 12px 18px; background: #94a3b8; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1.05em; transition: all 0.2s;">
                    ‚úó Use Default Instead
                </button>
            </div>
        </div>

        <!-- Manual Suggestion Display Button -->
        <div style="margin-bottom: 20px;">
            <button onclick="testAutoOpen()" style="display: block; width: 100%; padding: 12px; background: #3b82f6; color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 600; font-size: 1em;" id="testAutoOpenBtn">
                üí° Show Category Suggestion
            </button>
        </div>

        <!-- Category Management (Always Visible, Collapsible) -->
        <div style="margin-bottom: 20px;">
            <button class="settings-toggle-btn" id="categoryMgmtToggleBtn" style="display: flex; background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);">
                <span>üìö Manage Categories</span>
                <span class="toggle-icon">‚ñº</span>
            </button>
            <div class="category-manager" id="categoryManagerSection" style="display: none; margin-top: 10px;">
                <h4 style="color: #d97706;">Category Management</h4>

                <div class="category-section">
                    <strong>Current File:</strong>
                    <span id="currentFileDisplay">No file loaded</span>
                    <span class="category-badge" id="currentCategoryBadge">Default</span>
                </div>
                <div class="category-section">
                    <label style="display: block; margin-bottom: 5px;">Assign to Category:</label>
                    <div class="category-input-group">
                        <select id="categorySelect" style="flex: 1;">
                            <option value="Default">Default</option>
                        </select>
                        <select id="subcategorySelect" style="flex: 1;">
                            <option value="">No Subcategory</option>
                        </select>
                        <button onclick="assignCategory()">Assign</button>
                    </div>
                </div>
                <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                <div class="category-section">
                    <strong>Create New Category:</strong>
                    <div class="category-input-group">
                        <input type="text" id="newCategoryName" placeholder="e.g., Spanish" style="flex: 1;">
                        <button onclick="createCategory()">+ Add Category</button>
                    </div>
                </div>
                <div class="category-section">
                    <strong>Add Subcategory:</strong>
                    <div class="category-input-group">
                        <select id="parentCategorySelect" style="flex: 1;">
                            <option value="Default">Default</option>
                        </select>
                        <input type="text" id="newSubcategoryName" placeholder="e.g., A1 Vocabulary" style="flex: 1;">
                        <button onclick="createSubcategory()">+ Add Sub</button>
                    </div>
                </div>
                <div class="category-section">
                    <strong>All Categories:</strong>
                    <div class="category-list" id="categoryList">
                        <div class="category-item">
                            <span>üìÅ Default</span>
                            <span style="font-size: 0.8em; color: #78350f;">Built-in</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- Language Selector (Hidden until file is loaded) -->
        <div class="language-selector" id="languageSelector" style="display: none; background: linear-gradient(135deg, #10b981 0%, #059669 100%); padding: 25px; border-radius: 15px; margin-bottom: 25px; border: 3px solid #10b981; box-shadow: 0 8px 20px rgba(16, 185, 129, 0.3);">
            <h3 style="margin: 0 0 10px 0; color: white; font-size: 1.3em; text-align: center;">üó£Ô∏è Step 1: Select Your Languages</h3>
            <p style="margin: 0 0 20px 0; color: rgba(255,255,255,0.95); font-size: 0.95em; text-align: center; font-weight: 500;">
                ‚ö° <strong>Auto-detect</strong> is enabled by default for best results!
            </p>
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                <div style="background: white; padding: 15px; border-radius: 10px;">
                    <label id="sourceLanguageLabel" style="display: block; margin-bottom: 8px; font-weight: 600; color: #333; font-size: 0.95em;">
                        üåç Source Language (Learning From):
                    </label>
                    <select id="sourceLanguageSelect" style="width: 100%; padding: 12px; border: 2px solid #10b981; border-radius: 8px; font-size: 15px; background: white; font-weight: 500;">
                        <option value="" style="font-weight: bold; background: #d1fae5;">ü§ñ Auto-detect (Recommended)</option>
                        <option value="de">German (Deutsch)</option>
                        <option value="en">English</option>
                        <option value="es">Spanish (Espa√±ol)</option>
                        <option value="fr">French (Fran√ßais)</option>
                        <option value="it">Italian (Italiano)</option>
                        <option value="pt">Portuguese (Portugu√™s)</option>
                        <option value="ru">Russian (–†—É—Å—Å–∫–∏–π)</option>
                        <option value="ja">Japanese (Êó•Êú¨Ë™û)</option>
                        <option value="ko">Korean (ÌïúÍµ≠Ïñ¥)</option>
                        <option value="zh">Chinese (‰∏≠Êñá)</option>
                        <option value="ar">Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©)</option>
                        <option value="hi">Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                        <option value="nl">Dutch (Nederlands)</option>
                        <option value="pl">Polish (Polski)</option>
                        <option value="tr">Turkish (T√ºrk√ße)</option>
                        <option value="sv">Swedish (Svenska)</option>
                        <option value="da">Danish (Dansk)</option>
                        <option value="no">Norwegian (Norsk)</option>
                        <option value="fi">Finnish (Suomi)</option>
                    </select>
                </div>
                <div style="background: white; padding: 15px; border-radius: 10px;">
                    <label id="targetLanguageLabel" style="display: block; margin-bottom: 8px; font-weight: 600; color: #333; font-size: 0.95em;">
                        üéØ Target Language (Learning To):
                    </label>
                    <select id="targetLanguageSelect" style="width: 100%; padding: 12px; border: 2px solid #10b981; border-radius: 8px; font-size: 15px; background: white; font-weight: 500;">
                        <option value="" style="font-weight: bold; background: #d1fae5;">ü§ñ Auto-detect (Recommended)</option>
                        <option value="de">German (Deutsch)</option>
                        <option value="en" selected>English</option>
                        <option value="es">Spanish (Espa√±ol)</option>
                        <option value="fr">French (Fran√ßais)</option>
                        <option value="it">Italian (Italiano)</option>
                        <option value="pt">Portuguese (Portugu√™s)</option>
                        <option value="ru">Russian (–†—É—Å—Å–∫–∏–π)</option>
                        <option value="ja">Japanese (Êó•Êú¨Ë™û)</option>
                        <option value="ko">Korean (ÌïúÍµ≠Ïñ¥)</option>
                        <option value="zh">Chinese (‰∏≠Êñá)</option>
                        <option value="ar">Arabic (ÿßŸÑÿπÿ±ÿ®Ÿäÿ©)</option>
                        <option value="hi">Hindi (‡§π‡§ø‡§®‡•ç‡§¶‡•Ä)</option>
                        <option value="nl">Dutch (Nederlands)</option>
                        <option value="pl">Polish (Polski)</option>
                        <option value="tr">Turkish (T√ºrk√ße)</option>
                        <option value="sv">Swedish (Svenska)</option>
                        <option value="da">Danish (Dansk)</option>
                        <option value="no">Norwegian (Norsk)</option>
                        <option value="fi">Finnish (Suomi)</option>
                    </select>
                </div>
            </div>
            <div style="margin-top: 15px; padding: 12px; background: rgba(255, 255, 255, 0.95); border-radius: 8px; font-size: 0.9em; color: #065f46; border: 2px solid rgba(255,255,255,0.5);">
                üí° <strong>How Auto-detect Works:</strong> The app will automatically select the best pronunciation voices based on your CSV content. You can override this by manually selecting languages above.
            </div>
        </div>

        <!-- Format Selection Interface -->
        <div class="format-selector" id="formatSelector" style="display: none;">
            <h3>üìã Step 2: Choose How to Load Your File</h3>
            <p style="margin-bottom: 20px; color: #666;">Select the best method for your CSV format:</p>

            <!-- Option 1: Predefined Formats -->
            <div class="format-option" style="background: #e0f2fe; border: 3px solid #0284c7; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer;" onclick="selectPredefinedFormat()">
                <h4 style="color: #0284c7; margin: 0 0 10px 0;">‚ö° Option 1: Quick Predefined Format</h4>
                <p style="margin: 0 0 15px 0; font-size: 0.9em; color: #666;">Choose from common CSV formats. Fastest option!</p>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;" id="predefinedFormats">
                    <button class="format-preset-btn" data-format="3col-standard">
                        <strong>üìå 3-Column Standard</strong><br>
                        <span style="font-size: 0.85em;">Source, Source Example, Target</span>
                    </button>
                    <button class="format-preset-btn" data-format="3col-reverse">
                        <strong>üìå 3-Column Reverse</strong><br>
                        <span style="font-size: 0.85em;">Target, Target Example, Source</span>
                    </button>
                    <button class="format-preset-btn" data-format="4col-full">
                        <strong>üìå 4-Column Full</strong><br>
                        <span style="font-size: 0.85em;">Source, Source Ex., Target, Target Ex.</span>
                    </button>
                    <button class="format-preset-btn" data-format="2col-simple">
                        <strong>üìå 2-Column Simple</strong><br>
                        <span style="font-size: 0.85em;">Source, Target (no examples)</span>
                    </button>
                </div>
            </div>

            <!-- Option 2: Manual Mapping -->
            <div class="format-option" style="background: #fef3c7; border: 3px solid #f59e0b; padding: 20px; border-radius: 12px; margin-bottom: 15px; cursor: pointer;" onclick="selectManualMapping()">
                <h4 style="color: #f59e0b; margin: 0 0 10px 0;">üéØ Option 2: Manual Column Mapping</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">Manually assign each column. Full control for custom formats.</p>
            </div>

            <!-- Option 3: Auto-Detection -->
            <div class="format-option" style="background: #dbeafe; border: 3px solid #667eea; padding: 20px; border-radius: 12px; cursor: pointer;" onclick="selectAutoDetection()">
                <h4 style="color: #667eea; margin: 0 0 10px 0;">ü§ñ Option 3: Smart Auto-Detection</h4>
                <p style="margin: 0; font-size: 0.9em; color: #666;">AI-powered detection analyzes your data automatically. Works for most formats.</p>
            </div>
        </div>

        <!-- Manual Column Mapping Modal Popup -->
        <div class="modal-overlay" id="columnMapperModal" style="display: none;">
            <div class="modal-content" style="max-width: 95%; width: 1400px;">
                <div class="modal-header">
                    <h3>üéØ Manual Column Mapping</h3>
                    <button class="modal-close" onclick="closeColumnMapperModal()">‚úï</button>
                </div>
                <div class="modal-body">
                    <p style="margin-bottom: 20px; color: #666; font-size: 0.95em;">
                        Click on each column header to assign its type. Preview shows first 10 rows of your data.
                    </p>

                    <!-- Data Preview Table -->
                    <div style="overflow-x: auto; overflow-y: visible; margin-bottom: 20px;">
                        <table id="dataPreviewTable" style="width: 100%; border-collapse: collapse; font-size: 0.9em;">
                            <!-- Will be populated dynamically -->
                        </table>
                    </div>

                    <!-- Type Selection Buttons -->
                    <div style="background: #f0f9ff; padding: 15px; border-radius: 10px; margin-bottom: 15px;">
                        <strong style="color: #667eea;">üìã Available Column Types:</strong>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 10px;">
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #10b981;">
                                <strong style="color: #10b981;">üåç Source Word</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Main vocab shown immediately</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #f59e0b;">
                                <strong style="color: #f59e0b;">üìù Source Example</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Hidden until revealed</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #10b981;">
                                <strong style="color: #10b981;">üéØ Target Word</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Main translation shown immediately</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #f59e0b;">
                                <strong style="color: #f59e0b;">üìù Target Example</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Hidden until revealed</div>
                            </div>
                            <div style="padding: 10px; background: white; border-radius: 6px; border: 2px solid #94a3b8;">
                                <strong style="color: #64748b;">üö´ Ignore</strong>
                                <div style="font-size: 0.8em; color: #666; margin-top: 3px;">Skip this column</div>
                            </div>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; margin-top: 15px;">
                        <button class="control-btn" id="applyMappingBtnModal" style="flex: 1; background: #10b981;" onclick="processWithManualMapping()">
                            ‚úì Apply & Load Cards
                        </button>
                        <button class="control-btn" style="flex: 1; background: #94a3b8;" onclick="closeColumnMapperModal()">
                            ‚úï Cancel
                        </button>
                    </div>
                </div>
            </div>
        </div>


        <!-- Instructions (Collapsible) -->
        <div class="instructions" id="instructions" style="cursor: pointer;" onclick="this.style.display='none'">
            <h3>üìã CSV Format Instructions - v3.0 Universal (Click to hide):</h3>
            <p><strong>‚ú® Universal Language Support!</strong> Works with any language pair!</p>
            <p style="margin-top: 10px;"><strong>Supported Separators:</strong></p>
            <p>‚úÖ Comma (,) | ‚úÖ Semicolon (;) | ‚úÖ Pipe (|) | ‚úÖ Tab - All auto-detected!</p>
            <p style="margin-top: 10px;"><strong>Supported Formats:</strong></p>
            <p><strong>Basic:</strong> <code>SourceWord,TargetWord</code> or <code>TargetWord,SourceWord</code></p>
            <p><strong>Extended:</strong> <code>SourceWord,SourceExample,TargetWord,TargetExample</code></p>
            <p style="margin-top: 10px;"><strong>Examples (any language pair):</strong></p>
            <code>Bonjour,Hello</code> (French ‚Üí English)<br>
            <code>„Åì„Çì„Å´„Å°„ÅØ,Hello</code> (Japanese ‚Üí English)<br>
            <code>Source|Long source example|Target|Long target example</code> (with extended content)<br>
            <p style="margin-top: 10px;">‚úÖ Any separator | ‚úÖ Any column order | ‚úÖ Any languages | ‚úÖ Extended text supported</p>
        </div>

        <!-- Stats (Always Visible When File Loaded) -->
        <div class="stats" id="stats">
            <div class="stats-item">
                <span class="stats-value" id="learnedCount">0</span>
                <span>Learned</span>
            </div>
            <div class="stats-item">
                <span class="stats-value" id="remainingCount">0</span>
                <span>Remaining</span>
            </div>
            <div class="stats-item">
                <span class="stats-value" id="totalCount">0</span>
                <span>Total</span>
            </div>
        </div>

        <!-- Quick Actions (Always Visible When File Loaded) -->
        <div class="quick-actions" id="quickActions">
            <button class="quick-action-btn autoplay-btn" id="autoplayBtn">‚ñ∂ Auto-Play</button>
            <button class="quick-action-btn" id="shuffleBtn">üîÄ Shuffle</button>
            <button class="quick-action-btn" id="learnedBtn">‚úì Mark Learned</button>
            <button class="quick-action-btn" id="showLearnedBtn">üëÅ Unlearned Only</button>
            <button class="quick-action-btn" id="remapColumnsBtn" style="background: #f59e0b;">üéØ Remap Columns</button>
        </div>

        <!-- Settings Menu Toggle Button -->
        <button class="settings-toggle-btn" id="settingsToggleBtn">
            <span>‚öôÔ∏è Settings & Options</span>
            <span class="toggle-icon">‚ñº</span>
        </button>

        <!-- Settings Menu (Collapsible Accordion) -->
        <div class="settings-menu" id="settingsMenu">

            <!-- Category Management Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üìö Category Management</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <div class="category-section">
                        <strong>Current File:</strong>
                        <span id="currentFileDisplay">No file loaded</span>
                        <span class="category-badge" id="currentCategoryBadge">Default</span>
                    </div>
                    <div class="category-section">
                        <label style="display: block; margin-bottom: 5px;">Assign to Category:</label>
                        <div class="category-input-group">
                            <select id="categorySelect" style="flex: 1;">
                                <option value="Default">Default</option>
                            </select>
                            <select id="subcategorySelect" style="flex: 1;">
                                <option value="">No Subcategory</option>
                            </select>
                            <button onclick="assignCategory()">Assign</button>
                        </div>
                    </div>
                    <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                    <div class="category-section">
                        <strong>Create New Category:</strong>
                        <div class="category-input-group">
                            <input type="text" id="newCategoryName" placeholder="e.g., German" style="flex: 1;">
                            <button onclick="createCategory()">+ Add Category</button>
                        </div>
                    </div>
                    <div class="category-section">
                        <strong>Add Subcategory:</strong>
                        <div class="category-input-group">
                            <select id="parentCategorySelect" style="flex: 1;">
                                <option value="Default">Default</option>
                            </select>
                            <input type="text" id="newSubcategoryName" placeholder="e.g., A1 Vocabulary" style="flex: 1;">
                            <button onclick="createSubcategory()">+ Add Sub</button>
                        </div>
                    </div>
                    <div class="category-section">
                        <strong>All Categories:</strong>
                        <div class="category-list" id="categoryList">
                            <div class="category-item">
                                <span>üìÅ Default</span>
                                <span style="font-size: 0.8em; color: #78350f;">Built-in</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Voice & Speech Settings Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üéôÔ∏è Voice & Speech Settings <span style="font-size: 0.8em; color: #888;">(v2.4 Enhanced)</span></span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <div style="background: #f0f8ff; padding: 10px; border-radius: 5px; margin-bottom: 15px; font-size: 0.9em; border-left: 3px solid #667eea;">
                        <strong>üîä = Google voices (recommended, highest quality)</strong><br>
                        <strong>üéôÔ∏è = Microsoft voices (high quality)</strong><br>
                        <span style="color: #666;">Tip: Google voices provide the most natural pronunciation for learning!</span>
                    </div>
                    <label>
                        <span><strong>Source Language Voice:</strong></span>
                        <select id="sourceVoiceSelect" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px;"></select>
                        <div id="sourceVoiceInfo" style="font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic;">Loading voices...</div>
                    </label>
                    <label style="margin-top: 15px;">
                        <span><strong>Target Language Voice:</strong></span>
                        <select id="targetVoiceSelect" style="width: 100%; padding: 8px; margin-top: 5px; border: 2px solid #667eea; border-radius: 5px; font-size: 14px;"></select>
                        <div id="targetVoiceInfo" style="font-size: 0.85em; color: #666; margin-top: 5px; font-style: italic;">Loading voices...</div>
                    </label>
                    <label style="margin-top: 15px;">
                        <span>Speech Rate:</span>
                        <input type="range" id="speechRate" min="0.5" max="1.5" step="0.1" value="0.8">
                        <span class="delay-value" id="speechRateValue">0.8x</span>
                        <div style="font-size: 0.8em; color: #888; margin-top: 3px;">Slower (0.5x) ‚Üê ‚Üí Faster (1.5x)</div>
                    </label>
                    <label>
                        <span>Pitch:</span>
                        <input type="range" id="speechPitch" min="0.5" max="2" step="0.1" value="1.0">
                        <span class="delay-value" id="speechPitchValue">1.0</span>
                        <div style="font-size: 0.8em; color: #888; margin-top: 3px;">Lower (0.5) ‚Üê ‚Üí Higher (2.0)</div>
                    </label>
                </div>
            </div>

            <!-- Auto-Play Settings Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>‚ñ∂ Auto-Play Settings</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <label>
                        <input type="checkbox" id="autoplayEnglish">
                        <span>Pronounce English translation (after German)</span>
                    </label>
                    <label>
                        <span>Delay between German & English:</span>
                        <input type="range" id="delayBetween" min="500" max="3000" step="100" value="1500">
                        <span class="delay-value" id="delayBetweenValue">1.5s</span>
                    </label>
                    <label>
                        <span>Delay before next card:</span>
                        <input type="range" id="delayNext" min="1000" max="5000" step="200" value="2500">
                        <span class="delay-value" id="delayNextValue">2.5s</span>
                    </label>
                    <hr style="border: 1px solid #e2e8f0; margin: 15px 0;">
                    <label>
                        <input type="checkbox" id="recordSession">
                        <span>üéôÔ∏è Record Session Audio</span>
                    </label>
                    <div id="recordingControls" style="display: none; margin: 15px 0; padding: 15px; background: #fee2e2; border-radius: 8px; border: 2px solid #ef4444;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <span style="color: #dc2626; font-weight: 600;">‚è∫ Recording in progress...</span>
                            <span id="recordingTime" style="color: #dc2626; font-weight: bold;">0:00</span>
                        </div>
                        <button class="control-btn" id="stopRecordingBtn" style="background: #ef4444; width: 100%;">
                            ‚èπ Stop Recording
                        </button>
                    </div>
                    <div id="recordedAudioSection" style="display: none; margin: 15px 0; padding: 15px; background: #d1fae5; border-radius: 8px; border: 2px solid #10b981;">
                        <strong style="color: #065f46;">‚úì Recording Saved!</strong>
                        <div style="margin-top: 10px; display: flex; gap: 10px;">
                            <button class="control-btn" id="downloadRecordingBtn" style="background: #10b981; flex: 1;">
                                ‚¨á Download Audio
                            </button>
                            <button class="control-btn" id="playRecordingBtn" style="background: #3b82f6; flex: 1;">
                                ‚ñ∂ Play Recording
                            </button>
                        </div>
                        <audio id="recordedAudio" controls style="width: 100%; margin-top: 10px; display: none;"></audio>
                    </div>
                </div>
            </div>

            <!-- Advanced Features Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üéØ Advanced Features</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <label>
                        <input type="checkbox" id="loopMode">
                        <span>üîÅ Loop Mode - Restart automatically when finished</span>
                    </label>
                    <label>
                        <input type="checkbox" id="repeatMode">
                        <span>üó£Ô∏è Repeat Each Card:</span>
                        <select id="repeatCount" style="margin-left: 10px; padding: 4px;">
                            <option value="2">2 times</option>
                            <option value="3">3 times</option>
                            <option value="4">4 times</option>
                            <option value="5">5 times</option>
                        </select>
                    </label>
                    <label>
                        <input type="checkbox" id="studyTimer">
                        <span>‚è∞ Study Timer:</span>
                        <select id="studyDuration" style="margin-left: 10px; padding: 4px;">
                            <option value="5">5 minutes</option>
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                            <option value="60">60 minutes</option>
                        </select>
                    </label>
                    <label>
                        <input type="checkbox" id="sleepTimer">
                        <span>üìö Sleep Timer:</span>
                        <select id="sleepDuration" style="margin-left: 10px; padding: 4px;">
                            <option value="10">10 minutes</option>
                            <option value="15">15 minutes</option>
                            <option value="20">20 minutes</option>
                            <option value="30">30 minutes</option>
                            <option value="45">45 minutes</option>
                        </select>
                    </label>
                </div>
            </div>

            <!-- Display Options Accordion -->
            <div class="accordion-item">
                <div class="accordion-header" onclick="toggleAccordion(this)">
                    <span>üëÅÔ∏è Display Options</span>
                    <span class="accordion-icon">‚ñº</span>
                </div>
                <div class="accordion-content">
                    <label style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="checkbox" id="alwaysShowMeanings">
                        <span>Always show English meanings</span>
                    </label>
                    <label style="display: flex; align-items: center; gap: 10px; margin: 10px 0;">
                        <input type="checkbox" id="readExtendedContent">
                        <span>üìñ Read Extended Examples/Sentences in Auto-Play</span>
                    </label>
                    <button class="control-btn" id="focusModeBtn" style="width: 100%; margin-top: 10px; background: #6366f1;">
                        üéØ Enter Focus Mode
                    </button>
                    <button class="control-btn" id="resetBtn" style="width: 100%; margin-top: 10px; background: #ef4444;">
                        ‚Ü∫ Reset All Progress
                    </button>
                </div>
            </div>

        </div>

        <!-- Timer Display (Shows During Auto-Play) -->
        <div class="timer-display" id="timerDisplay">
            <span id="timerText">Time Remaining: 00:00</span>
        </div>

        <!-- Session Stats (Shows During Auto-Play) - Collapsible -->
        <div class="session-stats" id="sessionStats">
            <div class="session-stats-header" onclick="toggleSessionStats()">
                <h4>üìä Session Statistics</h4>
                <span class="session-stats-toggle" id="sessionStatsToggle">‚ñº</span>
            </div>
            <div class="session-stats-content" id="sessionStatsContent">
                <div class="stat-row">
                    <span class="stat-label">Cards Reviewed:</span>
                    <span class="stat-value" id="cardsReviewed">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Time Studying:</span>
                    <span class="stat-value" id="timeStudying">00:00</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Cards per Minute:</span>
                    <span class="stat-value" id="cardsPerMinute">0</span>
                </div>
                <div class="stat-row">
                    <span class="stat-label">Session Started:</span>
                    <span class="stat-value" id="sessionStart">--:--</span>
                </div>
            </div>
        </div>

        <!-- Practice Mode Button -->
        <button class="practice-mode-btn" id="practiceModeBtn" onclick="togglePracticeMode()">
            üéØ Start Practice Mode - Focus Only on Flashcards
        </button>

        <!-- Floating Practice Mode Controls -->
        <div class="practice-mode-controls" id="practiceModeControls">
            <button class="floating-control-btn stop" onclick="togglePracticeMode()">
                ‚èπÔ∏è Stop Practice
            </button>
            <button class="floating-control-btn" onclick="document.getElementById('settingsToggleBtn').click()">
                ‚öôÔ∏è Settings
            </button>
        </div>

        <div class="flashcard-container" id="flashcardContainer">
            <div class="flashcard" id="flashcard">
                <div class="card-source-section">
                    <button class="audio-btn" id="audioBtn" title="Pronounce source word">üîä</button>
                    <div class="learned-badge" id="learnedBadge" style="display: none;">‚úì Learned</div>
                    <div class="card-label">üåç Source Language</div>
                    <div class="card-content" id="sourceWord"></div>
                    <div class="review-info" id="reviewInfo"></div>
                    <hr class="card-divider">
                    <button class="reveal-btn" id="revealBtn">üëÅ Show Target Meaning</button>
                </div>
                <div class="card-target-section" id="targetSection">
                    <div class="card-label">üéØ Target Language</div>
                    <div class="card-content" id="targetWord"></div>
                    <div class="card-detail" id="detailBack"></div>
                    <button class="audio-btn-english" id="audioBtnEnglish" title="Pronounce target word">üîä</button>
                </div>
            </div>
            <div class="hint">üëÜ Click "Show Translation" or Space to reveal | üîä P for Source | E for Target pronunciation</div>
        </div>

        <div class="navigation" id="navigation">
            <button class="nav-button" id="prevBtn">‚Üê Previous</button>
            <div class="progress" id="progress">1 / 1</div>
            <button class="nav-button" id="nextBtn">Next ‚Üí</button>
        </div>
    </div>

    <script>
        // Cloud Sync Variables
        let cloudUser = null; // {username, passwordHash}
        let firebaseDB = null;
        let isCloudEnabled = false;

        // ===== FIREBASE CONFIGURATION =====
        // üîí SECURITY NOTE: This API key is SAFE to be public!
        //
        // Firebase API keys are designed to be included in client-side code.
        // According to Google's official documentation:
        // "Unlike how API keys are typically used, API keys for Firebase services
        // are not used to control access to backend resources."
        //
        // Actual security is provided by:
        // 1. Firebase Security Rules (configured in Firebase Console)
        // 2. Client-side encryption (all data encrypted with user password)
        // 3. Password hashing (SHA-256, stored securely)
        //
        // See FIREBASE_SECURITY_SETUP_GUIDE.md for complete security details.
        // ===================================
        const firebaseConfig = {
            apiKey: "AIzaSyCci_5AhIKW3VPnFu8LFBDJQxYQvPbOUlE",
            authDomain: "flashcard-sync-15835.firebaseapp.com",
            databaseURL: "https://flashcard-sync-15835-default-rtdb.firebaseio.com",
            projectId: "flashcard-sync-15835",
            storageBucket: "flashcard-sync-15835.firebasestorage.app",
            messagingSenderId: "220998447564",
            appId: "1:220998447564:web:d258c84f0cbfb882da2d69"
        };
        // ===================================

        let flashcards = [];
        let currentIndex = 0;
        let showOnlyUnlearned = false;
        let filteredCards = [];
        let currentFileName = '';
        let alwaysShowMeanings = false;
        let readExtendedContent = false; // New: toggle for reading extended examples/sentences

        // Column mapping variables
        let rawFileData = null;
        let detectedSeparator = ',';
        let columnMapping = null; // null = auto-detect, or {col0: 'german', col1: 'germanExtended', ...}

        // Category management
        let categories = {};
        let fileCategories = {};
        let currentFileCategory = { category: 'Default', subcategory: '' };

        // Auto-play variables
        let isAutoPlaying = false;
        let autoplayTimeout = null;
        let autoplayEnglishEnabled = false;
        let delayBetweenLangs = 1500; // milliseconds
        let delayBeforeNext = 2500; // milliseconds

        // Advanced feature variables
        let loopModeEnabled = false;
        let repeatModeEnabled = false;
        let repeatCount = 2;
        let currentRepeat = 0;
        let studyTimerEnabled = false;
        let sleepTimerEnabled = false;
        let timerInterval = null;
        let timerEndTime = null;

        // Session stats variables
        let sessionStartTime = null;
        let cardsReviewedCount = 0;
        let statsInterval = null;

        // Recording variables
        let mediaRecorder = null;
        let recordedChunks = [];
        let recordingStartTime = null;
        let recordingTimerInterval = null;
        let recordedAudioBlob = null;
        let isRecording = false;

        // Speech synthesis for audio pronunciation
        const synth = window.speechSynthesis;
        let sourceVoice = null;
        let targetVoice = null;
        let allVoices = [];
        let speechRate = 0.8;
        let speechPitch = 1.0;

        // Language selection
        let selectedSourceLanguage = ''; // Empty = auto-detect
        let selectedTargetLanguage = 'en'; // Default to English

        // Load voices - Universal version for any language
        function loadVoices() {
            allVoices = synth.getVoices();

            // Sort all voices by quality (Google > Microsoft > Others) and alphabetically
            const sortedVoices = [...allVoices].sort((a, b) => {
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                const aIsMicrosoft = a.name.toLowerCase().includes('microsoft');
                const bIsMicrosoft = b.name.toLowerCase().includes('microsoft');

                // Priority: Google > Microsoft > Others
                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                if (aIsMicrosoft && !bIsMicrosoft) return -1;
                if (!aIsMicrosoft && bIsMicrosoft) return 1;

                // Then sort alphabetically by language code
                return a.lang.localeCompare(b.lang);
            });

            // Set default voices based on selected languages
            if (selectedSourceLanguage) {
                // Find best voice for selected source language
                sourceVoice = sortedVoices.find(v => v.name.toLowerCase().includes('google') && v.lang.startsWith(selectedSourceLanguage))
                    || sortedVoices.find(v => v.lang.startsWith(selectedSourceLanguage))
                    || sortedVoices.find(v => v.name.toLowerCase().includes('google'))
                    || sortedVoices[0];
            } else {
                // Auto-detect: use first Google voice
                sourceVoice = sortedVoices.find(v => v.name.toLowerCase().includes('google')) || sortedVoices[0] || allVoices[0];
            }

            if (selectedTargetLanguage) {
                // Find best voice for selected target language
                targetVoice = sortedVoices.find(v => v.name.toLowerCase().includes('google') && v.lang.startsWith(selectedTargetLanguage))
                    || sortedVoices.find(v => v.lang.startsWith(selectedTargetLanguage))
                    || sortedVoices.find(v => v.name.toLowerCase().includes('google'))
                    || sortedVoices[0];
            } else {
                // Auto-detect: use English as default
                targetVoice = sortedVoices.find(v => v.name.toLowerCase().includes('google') && v.lang.startsWith('en')) || sortedVoices[0] || allVoices[0];
            }

            // Populate Source voice dropdown
            const sourceSelect = document.getElementById('sourceVoiceSelect');
            sourceSelect.innerHTML = '';
            sortedVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Enhanced label with provider indicators
                let label = voice.name;
                if (voice.name.toLowerCase().includes('google')) {
                    label = `üîä ${voice.name} (${voice.lang})`;
                } else if (voice.name.toLowerCase().includes('microsoft')) {
                    label = `üéôÔ∏è ${voice.name} (${voice.lang})`;
                } else {
                    label = `${voice.name} (${voice.lang})`;
                }

                option.textContent = label;

                // Mark default as selected
                if (voice === sourceVoice) {
                    option.selected = true;
                }

                sourceSelect.appendChild(option);
            });

            // Populate Target voice dropdown
            const targetSelect = document.getElementById('targetVoiceSelect');
            targetSelect.innerHTML = '';
            sortedVoices.forEach((voice, index) => {
                const option = document.createElement('option');
                option.value = index;

                // Enhanced label with provider indicators
                let label = voice.name;
                if (voice.name.toLowerCase().includes('google')) {
                    label = `üîä ${voice.name} (${voice.lang})`;
                } else if (voice.name.toLowerCase().includes('microsoft')) {
                    label = `üéôÔ∏è ${voice.name} (${voice.lang})`;
                } else {
                    label = `${voice.name} (${voice.lang})`;
                }

                option.textContent = label;

                // Mark default as selected
                if (voice === targetVoice) {
                    option.selected = true;
                }

                targetSelect.appendChild(option);
            });

            // Update voice info displays
            updateVoiceInfo('source', sourceVoice);
            updateVoiceInfo('target', targetVoice);

            // Log default voices for debugging
            console.log('‚úÖ v3.0 Universal Voice System Loaded');
            console.log('Default Source Voice:', sourceVoice ? sourceVoice.name : 'None');
            console.log('Default Target Voice:', targetVoice ? targetVoice.name : 'None');
            console.log('Total voices available:', allVoices.length);
        }

        // Update voice info display
        function updateVoiceInfo(language, voice) {
            const infoElement = document.getElementById(language + 'VoiceInfo');
            if (!voice || !infoElement) return;

            let info = '';
            const isGoogle = voice.name.toLowerCase().includes('google');
            const isMicrosoft = voice.name.toLowerCase().includes('microsoft');

            if (isGoogle) {
                info = 'üîä <strong>Google Voice</strong> - Premium quality, natural pronunciation (Recommended)';
            } else if (isMicrosoft) {
                info = 'üéôÔ∏è <strong>Microsoft Voice</strong> - High quality, clear enunciation';
            } else {
                info = 'üì¢ <strong>System Voice</strong> - Standard quality';
            }

            // Add voice details
            info += `<br><span style="color: #888;">Voice: ${voice.name} | Language: ${voice.lang}</span>`;

            infoElement.innerHTML = info;
        }

        // Load voices on page load
        if (synth.onvoiceschanged !== undefined) {
            synth.onvoiceschanged = loadVoices;
        }
        loadVoices();

        // ===== CLOUD SYNC FUNCTIONS =====

        // Simple hash function for password
        async function hashPassword(password) {
            const encoder = new TextEncoder();
            const data = encoder.encode(password);
            const hashBuffer = await crypto.subtle.digest('SHA-256', data);
            const hashArray = Array.from(new Uint8Array(hashBuffer));
            return hashArray.map(b => b.toString(16).padStart(2, '0')).join('');
        }

        // Encrypt data with password (AES-GCM)
        async function encryptData(data, password) {
            try {
                const encoder = new TextEncoder();
                const dataStr = JSON.stringify(data);

                // Generate key from password
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password.padEnd(32, '0').slice(0, 32)),
                    'AES-GCM',
                    false,
                    ['encrypt']
                );

                // Generate random IV
                const iv = crypto.getRandomValues(new Uint8Array(12));

                // Encrypt
                const encrypted = await crypto.subtle.encrypt(
                    { name: 'AES-GCM', iv: iv },
                    passwordKey,
                    encoder.encode(dataStr)
                );

                // Combine IV and encrypted data
                const combined = new Uint8Array(iv.length + encrypted.byteLength);
                combined.set(iv, 0);
                combined.set(new Uint8Array(encrypted), iv.length);

                // Convert to base64
                return btoa(String.fromCharCode(...combined));
            } catch (error) {
                console.error('Encryption error:', error);
                throw error;
            }
        }

        // Decrypt data with password
        async function decryptData(encryptedBase64, password) {
            try {
                // Decode base64
                const combined = new Uint8Array(atob(encryptedBase64).split('').map(c => c.charCodeAt(0)));

                // Extract IV and encrypted data
                const iv = combined.slice(0, 12);
                const encrypted = combined.slice(12);

                // Generate key from password
                const encoder = new TextEncoder();
                const passwordKey = await crypto.subtle.importKey(
                    'raw',
                    encoder.encode(password.padEnd(32, '0').slice(0, 32)),
                    'AES-GCM',
                    false,
                    ['decrypt']
                );

                // Decrypt
                const decrypted = await crypto.subtle.decrypt(
                    { name: 'AES-GCM', iv: iv },
                    passwordKey,
                    encrypted
                );

                const decoder = new TextDecoder();
                const dataStr = decoder.decode(decrypted);
                return JSON.parse(dataStr);
            } catch (error) {
                console.error('Decryption error:', error);
                throw error;
            }
        }

        // Initialize Firebase
        function initializeFirebase() {
            if (firebaseConfig.apiKey === "YOUR_API_KEY_HERE") {
                console.log('Firebase not configured yet');
                return false;
            }

            try {
                if (!firebase.apps.length) {
                    firebase.initializeApp(firebaseConfig);
                }
                firebaseDB = firebase.database();
                console.log('Firebase initialized successfully');
                return true;
            } catch (error) {
                console.error('Firebase initialization error:', error);
                return false;
            }
        }

        // Cloud Login
        async function cloudLogin() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;

            if (!username || !password) {
                alert('Please enter username and password');
                return;
            }

            if (username.length < 3) {
                alert('Username must be at least 3 characters');
                return;
            }

            if (password.length < 6) {
                alert('Password must be at least 6 characters');
                return;
            }

            // Initialize Firebase
            if (!initializeFirebase()) {
                alert('‚ö†Ô∏è Cloud sync not configured yet.\n\nPlease follow the setup instructions to enable cloud sync.\n\nFor now, using local storage only.');
                skipLogin();
                return;
            }

            try {
                // Hash password for storage
                const passwordHash = await hashPassword(password);

                cloudUser = {
                    username: username,
                    password: password, // Keep for encryption
                    passwordHash: passwordHash
                };

                // Save login info (encrypted)
                safeStorage.setItem('cloud_user', JSON.stringify({
                    username: username,
                    passwordHash: passwordHash
                }));

                isCloudEnabled = true;

                // Hide login modal
                document.getElementById('loginOverlay').style.display = 'none';

                // Show account button and sync status
                document.getElementById('accountButton').style.display = 'block';
                document.getElementById('syncStatus').style.display = 'block';
                updateSyncStatus('syncing', 'Syncing...');

                // Try to download existing data from cloud
                await downloadFromCloud();

                // Load categories (will use cloud data if available)
                loadCategories();

                // Refresh category browser to display downloaded categories
                renderCategoryBrowser();

                updateSyncStatus('synced', '‚òÅÔ∏è Synced');

                console.log('Cloud login successful');
            } catch (error) {
                console.error('Login error:', error);
                alert('Login failed. Please try again.');
            }
        }

        // Cloud Signup
        async function cloudSignup() {
            const username = document.getElementById('username').value.trim();
            const password = document.getElementById('password').value;
            const confirmPassword = document.getElementById('confirmPassword').value;

            if (!username || !password || !confirmPassword) {
                alert('Please fill in all fields');
                return;
            }

            if (username.length < 3) {
                alert('Username must be at least 3 characters');
                return;
            }

            if (password.length < 6) {
                alert('Password must be at least 6 characters');
                return;
            }

            if (password !== confirmPassword) {
                alert('Passwords do not match!');
                return;
            }

            // Initialize Firebase
            if (!initializeFirebase()) {
                alert('‚ö†Ô∏è Cloud sync not configured yet.\n\nPlease follow the setup instructions to enable cloud sync.\n\nFor now, using local storage only.');
                skipLogin();
                return;
            }

            try {
                // Check if username already exists
                const userPath = `users-universal/${username}`;
                const snapshot = await firebaseDB.ref(userPath).once('value');

                if (snapshot.exists()) {
                    alert('‚ùå Username already taken!\n\nPlease choose a different username or login if this is your account.');
                    return;
                }

                // Hash password for storage
                const passwordHash = await hashPassword(password);

                cloudUser = {
                    username: username,
                    password: password, // Keep for encryption
                    passwordHash: passwordHash
                };

                // Save login info
                safeStorage.setItem('cloud_user', JSON.stringify({
                    username: username,
                    passwordHash: passwordHash
                }));

                isCloudEnabled = true;

                // Hide login modal
                document.getElementById('loginOverlay').style.display = 'none';

                // Show account button and sync status
                document.getElementById('accountButton').style.display = 'block';
                document.getElementById('syncStatus').style.display = 'block';

                // Load categories (will be empty for new user)
                loadCategories();

                // Refresh category browser
                renderCategoryBrowser();

                // Upload initial empty categories to claim the username
                await uploadToCloud();

                updateSyncStatus('synced', '‚úÖ Account Created!');

                alert('‚úÖ Account created successfully!\n\nYour categories will now sync across all devices.');

                console.log('Cloud signup successful');
            } catch (error) {
                console.error('Signup error:', error);
                alert('Signup failed. Please try again.');
            }
        }

        // Safe localStorage wrapper (handles tracking prevention)
        const safeStorage = {
            getItem: function(key) {
                try {
                    return localStorage.getItem(key);
                } catch (e) {
                    console.warn('localStorage blocked by browser:', e);
                    return null;
                }
            },
            setItem: function(key, value) {
                try {
                    localStorage.setItem(key, value);
                } catch (e) {
                    console.warn('localStorage blocked by browser:', e);
                }
            },
            removeItem: function(key) {
                try {
                    localStorage.removeItem(key);
                } catch (e) {
                    console.warn('localStorage blocked by browser:', e);
                }
            }
        };

        // Toggle between Login and Signup modes
        function toggleLoginMode() {
            const title = document.getElementById('loginTitle');
            const subtitle = document.getElementById('loginSubtitle');
            const loginBtn = document.getElementById('loginBtn');
            const signupBtn = document.getElementById('signupBtn');
            const confirmPassword = document.getElementById('confirmPassword');
            const toggleText = document.getElementById('toggleText');

            if (loginBtn.style.display !== 'none') {
                // Switch to Signup mode
                title.textContent = 'üìù Create Account';
                subtitle.textContent = 'Sync your categories across all devices';
                loginBtn.style.display = 'none';
                signupBtn.style.display = 'block';
                confirmPassword.style.display = 'block';
                toggleText.innerHTML = 'Already have an account? <a href="#" onclick="window.toggleLoginMode(); return false;" style="color: #667eea; text-decoration: none; font-weight: bold;">Login</a>';
            } else {
                // Switch to Login mode
                title.textContent = '‚òÅÔ∏è Cloud Sync Login';
                subtitle.textContent = 'Access your categories from any device';
                loginBtn.style.display = 'block';
                signupBtn.style.display = 'none';
                confirmPassword.style.display = 'none';
                confirmPassword.value = '';
                toggleText.innerHTML = 'Don\'t have an account? <a href="#" onclick="window.toggleLoginMode(); return false;" style="color: #667eea; text-decoration: none; font-weight: bold;">Sign Up</a>';
            }
        }

        // Make functions globally accessible (fixes tracking prevention issues)
        window.toggleLoginMode = toggleLoginMode;
        window.cloudLogin = cloudLogin;
        window.cloudSignup = cloudSignup;
        window.skipLogin = skipLogin;

        // Skip Login (Local Only)
        function skipLogin() {
            isCloudEnabled = false;
            document.getElementById('loginOverlay').style.display = 'none';
            loadCategories();
            renderCategoryBrowser();
            console.log('Using local storage only');
        }

        // ===== ACCOUNT MANAGEMENT FUNCTIONS =====

        // Open Account Settings
        function openAccountSettings() {
            document.getElementById('accountModal').style.display = 'flex';
            document.getElementById('accountUsername').textContent = cloudUser ? cloudUser.username : '-';
            document.getElementById('accountStatus').textContent = isCloudEnabled ? '‚úÖ Connected' : '‚ùå Offline';
            const syncText = document.getElementById('syncStatusText').textContent;
            document.getElementById('accountSyncStatus').textContent = syncText;
        }

        // Close Account Settings
        function closeAccountSettings() {
            document.getElementById('accountModal').style.display = 'none';
            document.getElementById('changePasswordSection').style.display = 'none';
            document.getElementById('deleteAccountSection').style.display = 'none';
        }

        // Show Change Password Section
        function showChangePassword() {
            document.getElementById('changePasswordSection').style.display = 'block';
            document.getElementById('deleteAccountSection').style.display = 'none';
        }

        // Cancel Change Password
        function cancelChangePassword() {
            document.getElementById('changePasswordSection').style.display = 'none';
            document.getElementById('currentPassword').value = '';
            document.getElementById('newPassword').value = '';
            document.getElementById('confirmNewPassword').value = '';
        }

        // Change Password
        async function changePassword() {
            const currentPwd = document.getElementById('currentPassword').value;
            const newPwd = document.getElementById('newPassword').value;
            const confirmPwd = document.getElementById('confirmNewPassword').value;

            if (!currentPwd || !newPwd || !confirmPwd) {
                alert('Please fill in all password fields');
                return;
            }

            if (newPwd !== confirmPwd) {
                alert('New passwords do not match');
                return;
            }

            if (newPwd.length < 6) {
                alert('New password must be at least 6 characters');
                return;
            }

            if (!cloudUser || !firebaseDB) {
                alert('Not connected to cloud');
                return;
            }

            try {
                // Verify current password
                const currentHash = await hashPassword(currentPwd);
                if (currentHash !== cloudUser.passwordHash) {
                    alert('Current password is incorrect');
                    return;
                }

                updateSyncStatus('syncing', 'Changing password...');

                // Download and decrypt current data with old password
                const userPath = `users-universal/${cloudUser.username}`;
                const snapshot = await firebaseDB.ref(userPath).once('value');
                const cloudData = snapshot.val();

                if (!cloudData || !cloudData.data) {
                    alert('No data found to re-encrypt');
                    return;
                }

                // Decrypt with old password
                const decrypted = await decryptData(cloudData.data, currentPwd);
                if (!decrypted) {
                    alert('Failed to decrypt existing data');
                    return;
                }

                // Re-encrypt with new password
                const encrypted = await encryptData(decrypted, newPwd);

                // Generate new password hash
                const newHash = await hashPassword(newPwd);

                // Update in Firebase
                await firebaseDB.ref(userPath).update({
                    passwordHash: newHash,
                    data: encrypted,
                    lastModified: Date.now()
                });

                // Update local cloudUser object
                cloudUser.password = newPwd;
                cloudUser.passwordHash = newHash;

                // Update local storage
                safeStorage.setItem('cloud_user', JSON.stringify({
                    username: cloudUser.username,
                    passwordHash: newHash
                }));

                updateSyncStatus('synced', 'Synced');
                alert('‚úÖ Password changed successfully!\n\nYour data has been re-encrypted with the new password.');
                cancelChangePassword();

            } catch (error) {
                console.error('Password change error:', error);
                alert('Failed to change password: ' + error.message);
                updateSyncStatus('error', 'Error');
            }
        }

        // Show Delete Account Section
        function showDeleteAccount() {
            document.getElementById('deleteAccountSection').style.display = 'block';
            document.getElementById('changePasswordSection').style.display = 'none';
        }

        // Cancel Delete Account
        function cancelDeleteAccount() {
            document.getElementById('deleteAccountSection').style.display = 'none';
            document.getElementById('deletePassword').value = '';
        }

        // Confirm Delete Account
        async function confirmDeleteAccount() {
            const password = document.getElementById('deletePassword').value;

            if (!password) {
                alert('Please enter your password to confirm deletion');
                return;
            }

            if (!cloudUser || !firebaseDB) {
                alert('Not connected to cloud');
                return;
            }

            try {
                // Verify password
                const passwordHash = await hashPassword(password);
                if (passwordHash !== cloudUser.passwordHash) {
                    alert('Incorrect password');
                    return;
                }

                const confirmDelete = confirm(
                    '‚ö†Ô∏è FINAL WARNING ‚ö†Ô∏è\n\n' +
                    'This will permanently delete:\n' +
                    '‚Ä¢ All your categories\n' +
                    '‚Ä¢ All your vocabulary data\n' +
                    '‚Ä¢ Your account from the cloud\n\n' +
                    'This action CANNOT be undone!\n\n' +
                    'Are you absolutely sure?'
                );

                if (!confirmDelete) {
                    return;
                }

                updateSyncStatus('syncing', 'Deleting account...');

                // Delete from Firebase
                const userPath = `users-universal/${cloudUser.username}`;
                await firebaseDB.ref(userPath).remove();

                // Clear local data
                safeStorage.removeItem('cloud_user');
                safeStorage.removeItem('flashcard_categories');
                safeStorage.removeItem('flashcard_file_categories');

                // Reset app state
                cloudUser = null;
                isCloudEnabled = false;
                categories = { 'Default': [] };
                fileCategories = {};

                alert('‚úÖ Account deleted successfully.\n\nYou will be logged out now.');

                // Reload page
                window.location.reload();

            } catch (error) {
                console.error('Delete account error:', error);
                alert('Failed to delete account: ' + error.message);
                updateSyncStatus('error', 'Error');
            }
        }

        // Logout
        function logoutAccount() {
            const confirmLogout = confirm(
                'Are you sure you want to logout?\n\n' +
                'Your data is synced to the cloud and will be available when you login again.'
            );

            if (!confirmLogout) {
                return;
            }

            // Clear local session
            safeStorage.removeItem('cloud_user');

            // Reset app state
            cloudUser = null;
            isCloudEnabled = false;

            alert('‚úÖ Logged out successfully.\n\nYou can login again anytime to access your data.');

            // Reload page
            window.location.reload();
        }

        // Make account functions globally accessible
        window.openAccountSettings = openAccountSettings;
        window.closeAccountSettings = closeAccountSettings;
        window.showChangePassword = showChangePassword;
        window.cancelChangePassword = cancelChangePassword;
        window.changePassword = changePassword;
        window.showDeleteAccount = showDeleteAccount;
        window.cancelDeleteAccount = cancelDeleteAccount;
        window.confirmDeleteAccount = confirmDeleteAccount;
        window.logoutAccount = logoutAccount;

        // ===== END ACCOUNT MANAGEMENT FUNCTIONS =====

        // Upload to Cloud
        async function uploadToCloud() {
            if (!isCloudEnabled || !cloudUser || !firebaseDB) {
                return;
            }

            try {
                updateSyncStatus('syncing', 'Uploading...');

                // Prepare data (ONLY categories, no personal info)
                const dataToSync = {
                    categories: categories,
                    fileCategories: fileCategories,
                    lastSync: Date.now()
                };

                // Encrypt data
                const encrypted = await encryptData(dataToSync, cloudUser.password);

                // Upload to Firebase
                const userPath = `users-universal/${cloudUser.username}`;
                await firebaseDB.ref(userPath).set({
                    data: encrypted,
                    passwordHash: cloudUser.passwordHash,
                    lastModified: Date.now()
                });

                updateSyncStatus('synced', '‚òÅÔ∏è Synced');
                console.log('Data uploaded to cloud');
            } catch (error) {
                console.error('Upload error:', error);
                updateSyncStatus('error', '‚ùå Sync Failed');
            }
        }

        // Download from Cloud
        async function downloadFromCloud() {
            if (!isCloudEnabled || !cloudUser || !firebaseDB) {
                return;
            }

            try {
                updateSyncStatus('syncing', 'Downloading...');

                const userPath = `users-universal/${cloudUser.username}`;
                const snapshot = await firebaseDB.ref(userPath).once('value');
                const cloudData = snapshot.val();

                if (!cloudData) {
                    console.log('No cloud data found');
                    return;
                }

                // Verify password
                if (cloudData.passwordHash !== cloudUser.passwordHash) {
                    throw new Error('Invalid password');
                }

                // Decrypt data
                const decrypted = await decryptData(cloudData.data, cloudUser.password);

                // Update local data
                categories = decrypted.categories || {};
                fileCategories = decrypted.fileCategories || {};

                // Save to local storage
                safeStorage.setItem('flashcard_categories', JSON.stringify(categories));
                safeStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));

                console.log('Data downloaded from cloud');
            } catch (error) {
                console.error('Download error:', error);
                if (error.message === 'Invalid password') {
                    alert('‚ùå Invalid password');
                    cloudUser = null;
                    isCloudEnabled = false;
                    document.getElementById('loginOverlay').style.display = 'flex';
                }
            }
        }

        // Update sync status indicator
        function updateSyncStatus(status, text) {
            const statusEl = document.getElementById('syncStatus');
            const textEl = document.getElementById('syncStatusText');

            statusEl.className = 'sync-status ' + status;
            textEl.textContent = text;
            statusEl.style.display = 'block';

            // Hide after 3 seconds if synced
            if (status === 'synced') {
                setTimeout(() => {
                    statusEl.style.display = 'none';
                }, 3000);
            }
        }

        // Check if user is already logged in
        function checkExistingLogin() {
            const savedUser = safeStorage.getItem('cloud_user');
            if (savedUser) {
                // Show login modal to re-enter password
                // (We don't store password locally for security)
                document.getElementById('loginOverlay').style.display = 'flex';
                const userData = JSON.parse(savedUser);
                document.getElementById('username').value = userData.username;
            } else {
                document.getElementById('loginOverlay').style.display = 'flex';
            }
        }

        // ===== END CLOUD SYNC FUNCTIONS =====

        // Category Management Functions
        function loadCategories() {
            const saved = safeStorage.getItem('flashcard_categories');
            if (saved) {
                categories = JSON.parse(saved);
            } else {
                categories = { 'Default': [] };
            }

            const savedFiles = safeStorage.getItem('flashcard_file_categories');
            if (savedFiles) {
                fileCategories = JSON.parse(savedFiles);
            }

            updateCategoryDropdowns();
            renderCategoryList();
        }

        function saveCategories() {
            safeStorage.setItem('flashcard_categories', JSON.stringify(categories));
            safeStorage.setItem('flashcard_file_categories', JSON.stringify(fileCategories));

            // Auto-sync to cloud if enabled
            if (isCloudEnabled) {
                uploadToCloud();
            }
        }

        function createCategory() {
            const name = document.getElementById('newCategoryName').value.trim();
            if (!name) {
                alert('Please enter a category name');
                return;
            }
            if (categories[name]) {
                alert('Category already exists!');
                return;
            }

            categories[name] = [];
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            document.getElementById('newCategoryName').value = '';
            alert(`Category "${name}" created!`);
        }

        function createSubcategory() {
            const parent = document.getElementById('parentCategorySelect').value;
            const name = document.getElementById('newSubcategoryName').value.trim();

            if (!name) {
                alert('Please enter a subcategory name');
                return;
            }

            if (!categories[parent]) {
                alert('Parent category not found!');
                return;
            }

            if (categories[parent].includes(name)) {
                alert('Subcategory already exists!');
                return;
            }

            categories[parent].push(name);
            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            document.getElementById('newSubcategoryName').value = '';
            alert(`Subcategory "${name}" added to "${parent}"!`);
        }

        function assignCategory() {
            if (!currentFileName) {
                alert('No file loaded!');
                return;
            }

            const category = document.getElementById('categorySelect').value;
            const subcategory = document.getElementById('subcategorySelect').value;

            fileCategories[currentFileName] = { category, subcategory };
            currentFileCategory = { category, subcategory };

            saveCategories();
            updateCurrentFileDisplay();

            const subText = subcategory ? ` > ${subcategory}` : '';
            alert(`File mapped to: ${category}${subText}`);
        }

        function updateCategoryDropdowns() {
            const categorySelect = document.getElementById('categorySelect');
            const parentSelect = document.getElementById('parentCategorySelect');
            const subcategorySelect = document.getElementById('subcategorySelect');

            // Update category selects
            [categorySelect, parentSelect].forEach(select => {
                const current = select.value;
                select.innerHTML = '';
                Object.keys(categories).forEach(cat => {
                    const option = document.createElement('option');
                    option.value = cat;
                    option.textContent = cat;
                    select.appendChild(option);
                });
                if (current && categories[current]) {
                    select.value = current;
                }
            });

            // Update subcategory select
            updateSubcategoryDropdown();
        }

        function updateSubcategoryDropdown() {
            const category = document.getElementById('categorySelect').value;
            const subcategorySelect = document.getElementById('subcategorySelect');

            subcategorySelect.innerHTML = '<option value="">No Subcategory</option>';

            if (categories[category]) {
                categories[category].forEach(sub => {
                    const option = document.createElement('option');
                    option.value = sub;
                    option.textContent = sub;
                    subcategorySelect.appendChild(option);
                });
            }
        }

        function renderCategoryList() {
            const listDiv = document.getElementById('categoryList');
            listDiv.innerHTML = '';

            Object.keys(categories).forEach(cat => {
                const catDiv = document.createElement('div');
                catDiv.className = 'category-item';

                const catInfo = document.createElement('span');
                catInfo.innerHTML = `üìÅ <strong>${cat}</strong>`;

                const actions = document.createElement('div');
                if (cat !== 'Default') {
                    const deleteBtn = document.createElement('button');
                    deleteBtn.textContent = '‚úï';
                    deleteBtn.className = 'btn-small';
                    deleteBtn.style.background = '#ef4444';
                    deleteBtn.style.color = 'white';
                    deleteBtn.style.border = 'none';
                    deleteBtn.style.borderRadius = '4px';
                    deleteBtn.style.cursor = 'pointer';
                    deleteBtn.onclick = () => deleteCategory(cat);
                    actions.appendChild(deleteBtn);
                }

                catDiv.appendChild(catInfo);
                catDiv.appendChild(actions);
                listDiv.appendChild(catDiv);

                // Add subcategories
                if (categories[cat] && categories[cat].length > 0) {
                    categories[cat].forEach(sub => {
                        const subDiv = document.createElement('div');
                        subDiv.className = 'category-item subcategory-item';

                        const subInfo = document.createElement('span');
                        subInfo.innerHTML = `‚îî‚îÄ ${sub}`;

                        const subActions = document.createElement('div');
                        const deleteSubBtn = document.createElement('button');
                        deleteSubBtn.textContent = '‚úï';
                        deleteSubBtn.className = 'btn-small';
                        deleteSubBtn.style.background = '#f59e0b';
                        deleteSubBtn.style.color = 'white';
                        deleteSubBtn.style.border = 'none';
                        deleteSubBtn.style.borderRadius = '4px';
                        deleteSubBtn.style.cursor = 'pointer';
                        deleteSubBtn.onclick = () => deleteSubcategory(cat, sub);
                        subActions.appendChild(deleteSubBtn);

                        subDiv.appendChild(subInfo);
                        subDiv.appendChild(subActions);
                        listDiv.appendChild(subDiv);
                    });
                }
            });
        }

        function deleteCategory(category) {
            if (category === 'Default') {
                alert('Cannot delete Default category!');
                return;
            }

            if (!confirm(`Delete category "${category}" and all its subcategories?`)) {
                return;
            }

            delete categories[category];

            // Reassign files to Default
            Object.keys(fileCategories).forEach(file => {
                if (fileCategories[file].category === category) {
                    fileCategories[file] = { category: 'Default', subcategory: '' };
                }
            });

            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            alert(`Category "${category}" deleted!`);
        }

        function deleteSubcategory(category, subcategory) {
            if (!confirm(`Delete subcategory "${subcategory}"?`)) {
                return;
            }

            const index = categories[category].indexOf(subcategory);
            if (index > -1) {
                categories[category].splice(index, 1);
            }

            // Reassign files
            Object.keys(fileCategories).forEach(file => {
                if (fileCategories[file].category === category &&
                    fileCategories[file].subcategory === subcategory) {
                    fileCategories[file].subcategory = '';
                }
            });

            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();
            alert(`Subcategory "${subcategory}" deleted!`);
        }

        function updateCurrentFileDisplay() {
            if (currentFileName) {
                document.getElementById('currentFileDisplay').textContent = currentFileName;

                const cat = currentFileCategory.category || 'Default';
                const sub = currentFileCategory.subcategory;
                const badgeText = sub ? `${cat} > ${sub}` : cat;

                document.getElementById('currentCategoryBadge').textContent = badgeText;
            }
        }

        function filterByCategory() {
            // TODO: Implement filtering by category
            alert('Filter by category feature coming soon!');
        }

        // Category select change handler
        document.getElementById('categorySelect').addEventListener('change', updateSubcategoryDropdown);

        // Category Browser Functions
        function renderCategoryBrowser() {
            const browserList = document.getElementById('categoryBrowserList');
            const noMessage = document.getElementById('noCategoriesMessage');

            // Get all files organized by category
            const categoryFiles = {};

            Object.keys(fileCategories).forEach(fileName => {
                const cat = fileCategories[fileName].category || 'Default';
                const subcat = fileCategories[fileName].subcategory || '';

                if (!categoryFiles[cat]) {
                    categoryFiles[cat] = {};
                }

                if (subcat) {
                    if (!categoryFiles[cat][subcat]) {
                        categoryFiles[cat][subcat] = [];
                    }
                    categoryFiles[cat][subcat].push(fileName);
                } else {
                    if (!categoryFiles[cat]['_root']) {
                        categoryFiles[cat]['_root'] = [];
                    }
                    categoryFiles[cat]['_root'].push(fileName);
                }
            });

            // Check if we have any categories with files
            const hasCategories = Object.keys(categoryFiles).length > 0;

            if (!hasCategories) {
                browserList.innerHTML = '';
                noMessage.style.display = 'block';
                return;
            }

            noMessage.style.display = 'none';
            browserList.innerHTML = '';

            // Render each category
            Object.keys(categoryFiles).sort().forEach(category => {
                const categoryCard = document.createElement('div');
                categoryCard.style.cssText = `
                    background: white;
                    border: 2px solid #667eea;
                    border-radius: 10px;
                    padding: 15px;
                    cursor: pointer;
                    transition: all 0.3s;
                    box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                `;

                categoryCard.addEventListener('mouseenter', function() {
                    this.style.transform = 'translateY(-3px)';
                    this.style.boxShadow = '0 4px 12px rgba(102, 126, 234, 0.3)';
                });

                categoryCard.addEventListener('mouseleave', function() {
                    this.style.transform = 'translateY(0)';
                    this.style.boxShadow = '0 2px 4px rgba(0,0,0,0.1)';
                });

                // Count total files in this category
                let fileCount = 0;
                Object.keys(categoryFiles[category]).forEach(subcat => {
                    fileCount += categoryFiles[category][subcat].length;
                });

                // Category header
                const header = document.createElement('div');
                header.style.cssText = 'display: flex; align-items: center; justify-content: space-between; margin-bottom: 10px;';
                header.innerHTML = `
                    <div>
                        <div style="font-size: 1.3em; font-weight: 600; color: #667eea;">üìÅ ${category}</div>
                        <div style="font-size: 0.8em; color: #999; margin-top: 3px;">${fileCount} file${fileCount !== 1 ? 's' : ''}</div>
                    </div>
                `;

                categoryCard.appendChild(header);

                // Subcategories list
                const subcatList = document.createElement('div');
                subcatList.style.cssText = 'margin-top: 10px; padding-top: 10px; border-top: 1px solid #e0e0e0; font-size: 0.85em;';

                const subcats = Object.keys(categoryFiles[category]).filter(s => s !== '_root').sort();
                if (subcats.length > 0) {
                    subcats.forEach(subcat => {
                        const subcatItem = document.createElement('div');
                        subcatItem.style.cssText = 'padding: 6px 8px; margin: 2px 0; color: #555; cursor: pointer; border-radius: 6px; transition: all 0.2s; background: #f8f9fa;';
                        subcatItem.innerHTML = `‚îî <strong>${subcat}</strong> <span style="color: #999;">(${categoryFiles[category][subcat].length} file${categoryFiles[category][subcat].length !== 1 ? 's' : ''})</span>`;

                        // Hover effect
                        subcatItem.addEventListener('mouseenter', function() {
                            this.style.background = '#667eea';
                            this.style.color = 'white';
                            const span = this.querySelector('span');
                            if (span) span.style.color = '#e0e7ff';
                        });

                        subcatItem.addEventListener('mouseleave', function() {
                            this.style.background = '#f8f9fa';
                            this.style.color = '#555';
                            const span = this.querySelector('span');
                            if (span) span.style.color = '#999';
                        });

                        // Click handler for subcategory
                        subcatItem.addEventListener('click', (e) => {
                            e.stopPropagation();
                            loadSubcategoryVocabulary(category, subcat);
                        });

                        subcatList.appendChild(subcatItem);
                    });
                    categoryCard.appendChild(subcatList);
                }

                // Click handler to load category vocabulary
                categoryCard.addEventListener('click', (e) => {
                    if (e.target === categoryCard || e.target.closest('.category-card-header')) {
                        loadCategoryVocabulary(category);
                    }
                });

                browserList.appendChild(categoryCard);
            });
        }

        function loadCategoryVocabulary(categoryName) {
            const filesInCategory = Object.keys(fileCategories).filter(fileName => {
                return fileCategories[fileName].category === categoryName;
            });

            if (filesInCategory.length === 0) {
                alert(`No files found in category "${categoryName}"`);
                return;
            }

            if (filesInCategory.length > 1) {
                let message = `Select a file from "${categoryName}":\n\n`;
                filesInCategory.forEach((file, idx) => {
                    const subcat = fileCategories[file].subcategory;
                    message += `${idx + 1}. ${file}${subcat ? ' (' + subcat + ')' : ''}\n`;
                });

                const selection = prompt(message + '\nEnter file number:');
                if (selection) {
                    const index = parseInt(selection) - 1;
                    if (index >= 0 && index < filesInCategory.length) {
                        loadFileByName(filesInCategory[index]);
                    }
                }
            } else {
                loadFileByName(filesInCategory[0]);
            }
        }

        function loadSubcategoryVocabulary(categoryName, subcategoryName) {
            console.log('üìã Loading subcategory:', categoryName, '‚Üí', subcategoryName);

            const filesInSubcategory = Object.keys(fileCategories).filter(fileName => {
                return fileCategories[fileName].category === categoryName &&
                       fileCategories[fileName].subcategory === subcategoryName;
            });

            if (filesInSubcategory.length === 0) {
                alert(`No files found in subcategory "${categoryName} ‚Üí ${subcategoryName}"`);
                return;
            }

            if (filesInSubcategory.length > 1) {
                let message = `Select a file from "${categoryName} ‚Üí ${subcategoryName}":\n\n`;
                filesInSubcategory.forEach((file, idx) => {
                    message += `${idx + 1}. ${file}\n`;
                });

                const selection = prompt(message + '\nEnter file number:');
                if (selection) {
                    const index = parseInt(selection) - 1;
                    if (index >= 0 && index < filesInSubcategory.length) {
                        loadFileByName(filesInSubcategory[index]);
                    }
                }
            } else {
                loadFileByName(filesInSubcategory[0]);
            }
        }

        function loadFileByName(fileName) {
            const savedData = localStorage.getItem(`flashcards_${fileName}`);

            if (!savedData) {
                alert(`Vocabulary data for "${fileName}" not found. Please upload the file again.`);
                return;
            }

            try {
                const cardData = JSON.parse(savedData);

                // Reconstruct flashcards from saved data (language-agnostic)
                flashcards = cardData.map((card, index) => ({
                    id: index,
                    source: card.source,
                    sourceExtended: card.sourceExtended || '',
                    target: card.target,
                    targetExtended: card.targetExtended || '',
                    detail: card.detail || '',
                    hasExtended: !!(card.sourceExtended || card.targetExtended),
                    learned: card.learned || false,
                    reviewDate: card.reviewDate || null,
                    repetitions: card.repetitions || 0,
                    easeFactor: card.easeFactor || 2.5,
                    interval: card.interval || 1
                }));

                currentFileName = fileName;
                currentIndex = 0;
                filteredCards = [...flashcards];

                if (fileCategories[currentFileName]) {
                    currentFileCategory = fileCategories[currentFileName];
                }

                const dueCount = flashcards.filter(isDueForReview).length;
                fileInfo.innerHTML = `<strong>üìÇ ${currentFileName}</strong><br>‚úÖ Loaded ${flashcards.length} cards (${dueCount} due for review) from saved data`;

                updateStats();
                showFlashcard();
                updateCurrentFileDisplay();

                flashcardContainer.style.display = 'block';
                navigation.style.display = 'flex';
                stats.style.display = 'block';
                document.getElementById('quickActions').style.display = 'grid';
                document.getElementById('practiceModeBtn').style.display = 'block';
                document.getElementById('settingsToggleBtn').style.display = 'flex';
                document.getElementById('clearFileBtn').style.display = 'inline-block';
                document.getElementById('languageSelector').style.display = 'block';

                alert(`‚úÖ Loaded "${fileName}" from saved data!\n\nüìö ${flashcards.length} cards ready to practice.`);
            } catch (error) {
                console.error('Error loading file:', error);
                alert(`Error loading "${fileName}". Data may be corrupted.`);
            }
        }

        // Category suggestion functions
        function showCategorySuggestion(category, subcategory) {
            console.log('üéØ showCategorySuggestion CALLED with:', category, subcategory);

            const section = document.getElementById('suggestedCategorySection');
            const categoryInput = document.getElementById('suggestedCategoryInput');
            const subcategoryInput = document.getElementById('suggestedSubcategoryInput');

            if (!section || !categoryInput || !subcategoryInput) {
                console.error('‚ùå Required elements not found for category suggestion');
                return;
            }

            if (!category) {
                console.log('No category detected, using Default');
                category = 'Default';
            }

            categoryInput.value = category || '';
            subcategoryInput.value = subcategory || '';

            console.log('üí° Showing suggestion box with:', category, subcategory);

            section.style.display = 'block';

            console.log('‚úÖ Suggestion box displayed prominently');

            setTimeout(() => {
                try {
                    section.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    categoryInput.focus();
                    categoryInput.select();
                } catch(e) {
                    console.error('Scroll/focus error:', e);
                }
            }, 300);
        }

        function applySuggestedCategory() {
            const categoryInput = document.getElementById('suggestedCategoryInput');
            const subcategoryInput = document.getElementById('suggestedSubcategoryInput');

            const category = categoryInput.value.trim();
            const subcategory = subcategoryInput.value.trim();

            if (!category) {
                alert('Please enter a category name!');
                categoryInput.focus();
                return;
            }

            console.log('‚úÖ User approved category:', category, subcategory);

            if (!categories[category]) {
                categories[category] = [];
                console.log('Created new category:', category);
            }

            if (subcategory && !categories[category].includes(subcategory)) {
                categories[category].push(subcategory);
                console.log('Created new subcategory:', subcategory);
            }

            saveCategories();
            updateCategoryDropdowns();
            renderCategoryList();

            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: category,
                    subcategory: subcategory || ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories();
                updateCurrentFileDisplay();

                console.log('‚úÖ File category assignment complete:', currentFileName, '‚Üí', category, subcategory);
            }

            document.getElementById('categorySelect').value = category;
            updateSubcategoryDropdown();
            if (subcategory) {
                document.getElementById('subcategorySelect').value = subcategory;
            }

            document.getElementById('suggestedCategorySection').style.display = 'none';

            renderCategoryBrowser();

            alert(`‚úì File assigned to: ${category}${subcategory ? ' > ' + subcategory : ''}\n\nüíæ Vocabulary saved and ready to practice!`);
        }

        function rejectSuggestion() {
            console.log('‚ùå User rejected suggestion, using Default');

            if (currentFileName) {
                fileCategories[currentFileName] = {
                    category: 'Default',
                    subcategory: ''
                };
                currentFileCategory = fileCategories[currentFileName];
                saveCategories();
                updateCurrentFileDisplay();

                console.log('‚úÖ File assigned to Default category:', currentFileName);
            }

            document.getElementById('categorySelect').value = 'Default';
            updateSubcategoryDropdown();

            document.getElementById('suggestedCategorySection').style.display = 'none';

            renderCategoryBrowser();

            alert('‚úì File assigned to Default category\n\nüíæ Vocabulary saved and ready to practice!');
        }

        function testAutoOpen() {
            console.log('üß™ TEST: Manual trigger of suggestion display');

            let testCategory = 'TestCategory';
            let testSubcategory = 'TestSubcategory';

            showCategorySuggestion(testCategory, testSubcategory);
            console.log('‚úÖ TEST: Suggestion display triggered');
        }

        // Load categories and render browser on page load
        loadCategories();
        renderCategoryBrowser();

        const csvFileInput = document.getElementById('csvFile');
        const fileInfo = document.getElementById('fileInfo');
        const flashcardContainer = document.getElementById('flashcardContainer');
        const flashcard = document.getElementById('flashcard');
        const navigation = document.getElementById('navigation');
        const sourceWord = document.getElementById('sourceWord');
        const targetWord = document.getElementById('targetWord');
        const detailBack = document.getElementById('detailBack');
        const progress = document.getElementById('progress');
        const prevBtn = document.getElementById('prevBtn');
        const nextBtn = document.getElementById('nextBtn');
        const controlButtons = document.getElementById('controlButtons');
        const stats = document.getElementById('stats');
        const learnedCount = document.getElementById('learnedCount');
        const remainingCount = document.getElementById('remainingCount');
        const totalCount = document.getElementById('totalCount');
        const shuffleBtn = document.getElementById('shuffleBtn');
        const learnedBtn = document.getElementById('learnedBtn');
        const resetBtn = document.getElementById('resetBtn');
        const showLearnedBtn = document.getElementById('showLearnedBtn');
        const learnedBadge = document.getElementById('learnedBadge');
        const audioBtn = document.getElementById('audioBtn');
        const reviewInfo = document.getElementById('reviewInfo');
        const targetSection = document.getElementById('targetSection');
        const revealBtn = document.getElementById('revealBtn');
        const alwaysShowMeaningsCheckbox = document.getElementById('alwaysShowMeanings');
        const showMeaningsToggle = document.getElementById('showMeaningsToggle');
        const audioBtnTarget = document.getElementById('audioBtnEnglish');

        // Auto-play elements
        const autoplayBtn = document.getElementById('autoplayBtn');
        const autoplaySettings = document.getElementById('autoplaySettings');
        const autoplayEnglishCheckbox = document.getElementById('autoplayEnglish');
        const delayBetweenSlider = document.getElementById('delayBetween');
        const delayNextSlider = document.getElementById('delayNext');
        const delayBetweenValue = document.getElementById('delayBetweenValue');
        const delayNextValue = document.getElementById('delayNextValue');

        // Handle file upload
        csvFileInput.addEventListener('change', (event) => {
            const file = event.target.files[0];
            if (file) {
                fileInfo.textContent = `Loading: ${file.name}`;
                parseCSV(file);
            }
        });

        // Handle clear file button
        document.getElementById('clearFileBtn').addEventListener('click', () => {
            if (confirm('Remove current file and reset? All unsaved progress will be kept in browser storage.')) {
                // Reset file input
                csvFileInput.value = '';

                // Clear current data
                flashcards = [];
                filteredCards = [];
                currentIndex = 0;
                currentFileName = '';

                // Stop any ongoing auto-play
                stopAutoPlay();

                // Hide UI elements
                flashcardContainer.style.display = 'none';
                navigation.style.display = 'none';
                stats.style.display = 'none';
                document.getElementById('quickActions').style.display = 'none';
                document.getElementById('settingsToggleBtn').style.display = 'none';
                document.getElementById('settingsMenu').style.display = 'none';
                document.getElementById('clearFileBtn').style.display = 'none';
                document.getElementById('sessionStats').style.display = 'none';
                document.getElementById('timerDisplay').style.display = 'none';
                document.getElementById('languageSelector').style.display = 'none';

                // Update file info
                fileInfo.textContent = 'File removed. Upload a new CSV file to continue.';

                // Show instructions again
                document.getElementById('instructions').style.display = 'block';
            }
        });

        // LocalStorage functions
        function saveProgress() {
            if (currentFileName && flashcards.length > 0) {
                const progressData = flashcards.map(card => ({
                    source: card.source,
                    target: card.target,
                    learned: card.learned,
                    reviewDate: card.reviewDate || null,
                    repetitions: card.repetitions || 0,
                    easeFactor: card.easeFactor || 2.5,
                    interval: card.interval || 1
                }));
                localStorage.setItem(`flashcards_${currentFileName}`, JSON.stringify(progressData));
            }
        }

        function loadProgress(fileName) {
            const saved = localStorage.getItem(`flashcards_${fileName}`);
            if (saved) {
                return JSON.parse(saved);
            }
            return null;
        }

        // Spaced Repetition Algorithm (SM-2)
        function calculateNextReview(card, quality) {
            // quality: 0-5 (0=total blackout, 5=perfect response)
            let easeFactor = card.easeFactor || 2.5;
            let repetitions = card.repetitions || 0;
            let interval = card.interval || 1;

            if (quality >= 3) {
                // Correct response
                if (repetitions === 0) {
                    interval = 1;
                } else if (repetitions === 1) {
                    interval = 6;
                } else {
                    interval = Math.round(interval * easeFactor);
                }
                repetitions++;
            } else {
                // Incorrect response - restart
                repetitions = 0;
                interval = 1;
            }

            // Update ease factor
            easeFactor = easeFactor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
            if (easeFactor < 1.3) easeFactor = 1.3;

            const nextReviewDate = new Date();
            nextReviewDate.setDate(nextReviewDate.getDate() + interval);

            return {
                repetitions,
                easeFactor,
                interval,
                reviewDate: nextReviewDate.toISOString()
            };
        }

        // Check if card is due for review
        function isDueForReview(card) {
            if (!card.reviewDate) return true;
            return new Date() >= new Date(card.reviewDate);
        }

        // Enhanced language detection with multiple language support
        function detectLanguageFromText(text) {
            if (!text) return null;

            const languagePatterns = {
                'de': {
                    chars: /[√§√∂√º√ü√Ñ√ñ√ú]/,
                    words: /\b(der|die|das|den|dem|des|ein|eine|einen|einem|eines|ich|du|er|sie|es|wir|ihr|und|oder|aber|auch|nicht|ist|sind|haben|hat|zu|auf|in|mit|von|f√ºr|sein|werden|k√∂nnen|m√ºssen|d√ºrfen|sollen|m√∂gen)\b/i,
                    score: 0
                },
                'en': {
                    chars: null,
                    words: /\b(the|a|an|and|or|but|in|on|at|to|for|of|with|by|from|is|are|was|were|be|been|have|has|had|do|does|did|will|would|can|could|should|may|might|must|this|that|these|those)\b/i,
                    score: 0
                },
                'es': {
                    chars: /[√°√©√≠√≥√∫√±√Å√â√ç√ì√ö√ë¬ø¬°]/,
                    words: /\b(el|la|los|las|un|una|de|del|y|o|pero|en|con|por|para|que|es|son|est√°|est√°n|ser|estar|tener|hacer)\b/i,
                    score: 0
                },
                'fr': {
                    chars: /[√†√¢√¶√ß√©√®√™√´√Ø√Æ√¥√π√ª√º√ø≈ì√Ä√Ç√Ü√á√â√à√ä√ã√è√é√î√ô√õ√ú≈∏≈í]/,
                    words: /\b(le|la|les|un|une|de|du|des|et|ou|mais|dans|avec|par|pour|que|qui|il|elle|est|sont|√™tre|avoir|faire)\b/i,
                    score: 0
                },
                'it': {
                    chars: /[√†√®√©√¨√≠√Æ√≤√≥√π√∫√Ä√à√â√å√ç√é√í√ì√ô√ö]/,
                    words: /\b(il|lo|la|i|gli|le|un|uno|una|di|del|e|o|ma|in|con|per|che|√®|sono|essere|avere|fare)\b/i,
                    score: 0
                },
                'pt': {
                    chars: /[√£√†√°√¢√ß√©√™√≠√≥√¥√µ√∫√É√Ä√Å√Ç√á√â√ä√ç√ì√î√ï√ö]/,
                    words: /\b(o|a|os|as|um|uma|de|do|da|e|ou|mas|em|com|por|para|que|√©|s√£o|ser|estar|ter|fazer)\b/i,
                    score: 0
                },
                'ru': {
                    chars: /[–∞-—è–ê-–Ø—ë–Å]/,
                    words: /\b(–∏|–≤|–Ω–µ|–Ω–∞|—è|–±—ã—Ç—å|—Å|–æ–Ω|—á—Ç–æ|—ç—Ç–æ|–∞|–∫–∞–∫|–Ω–æ|—Ç–æ|–≤–µ—Å—å|–æ–Ω–∞|—Ç–∞–∫–æ–π|–¥–ª—è|–ø–æ|–º—ã)\b/i,
                    score: 0
                },
                'ja': {
                    chars: /[\u3040-\u309F\u30A0-\u30FF\u4E00-\u9FAF]/,
                    words: null,
                    score: 0
                },
                'ko': {
                    chars: /[\uAC00-\uD7AF\u1100-\u11FF\u3130-\u318F]/,
                    words: null,
                    score: 0
                },
                'zh': {
                    chars: /[\u4E00-\u9FFF]/,
                    words: null,
                    score: 0
                },
                'ar': {
                    chars: /[\u0600-\u06FF]/,
                    words: null,
                    score: 0
                },
                'nl': {
                    chars: null,
                    words: /\b(de|het|een|en|of|maar|in|op|met|voor|van|is|zijn|was|waren|hebben|heeft)\b/i,
                    score: 0
                },
                'pl': {
                    chars: /[ƒÖƒáƒô≈Ç≈Ñ√≥≈õ≈∫≈ºƒÑƒÜƒò≈Å≈É√ì≈ö≈π≈ª]/,
                    words: /\b(i|w|na|do|z|o|≈ºe|siƒô|nie|byƒá|mieƒá|m√≥c|to|ten|ten|dla|po)\b/i,
                    score: 0
                },
                'tr': {
                    chars: /[√ßƒüƒ±ƒ∞√∂≈ü√º√áƒû√ñ≈û√ú]/,
                    words: /\b(ve|bir|bu|i√ßin|ile|de|da|ki|mi|var|gibi|daha|√ßok|ne|kadar)\b/i,
                    score: 0
                }
            };

            // Score each language
            for (const [langCode, pattern] of Object.entries(languagePatterns)) {
                let score = 0;

                // Check for special characters
                if (pattern.chars && pattern.chars.test(text)) {
                    score += 10; // High score for special characters
                }

                // Check for common words
                if (pattern.words) {
                    const matches = text.match(pattern.words);
                    if (matches) {
                        score += matches.length * 2; // Score based on number of matches
                    }
                }

                languagePatterns[langCode].score = score;
            }

            // Find language with highest score
            let maxScore = 0;
            let detectedLang = null;

            for (const [langCode, pattern] of Object.entries(languagePatterns)) {
                if (pattern.score > maxScore) {
                    maxScore = pattern.score;
                    detectedLang = langCode;
                }
            }

            // Return detected language if score is significant
            return maxScore > 3 ? detectedLang : null;
        }

        // Detect languages from entire CSV content
        function detectLanguagesFromCSV(text) {
            if (!text) return { source: null, target: null };

            const lines = text.split('\n').filter(line => line.trim() !== '');
            const separator = detectSeparator(text);

            // Skip header if present
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('german') || firstLine.includes('english') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            // Sample up to 20 rows for detection
            const sampleLines = lines.slice(startIndex, Math.min(startIndex + 20, lines.length));

            // Collect text from first and second columns
            let sourceTexts = [];
            let targetTexts = [];

            sampleLines.forEach(line => {
                const parts = line.split(separator).map(p => p.trim());
                if (parts.length >= 2) {
                    sourceTexts.push(parts[0]);
                    targetTexts.push(parts[1]);
                }
            });

            // Detect languages
            const sourceText = sourceTexts.join(' ');
            const targetText = targetTexts.join(' ');

            const sourceLang = detectLanguageFromText(sourceText);
            const targetLang = detectLanguageFromText(targetText);

            console.log('Language Detection Results:', {
                source: sourceLang,
                target: targetLang,
                sourceTexts: sourceTexts.slice(0, 3),
                targetTexts: targetTexts.slice(0, 3)
            });

            return { source: sourceLang, target: targetLang };
        }

        // Update language selector UI with detected language
        function updateLanguageSelectorWithDetection(sourceLang, targetLang) {
            const sourceSelect = document.getElementById('sourceLanguageSelect');
            const targetSelect = document.getElementById('targetLanguageSelect');
            const sourceLabel = document.getElementById('sourceLanguageLabel');
            const targetLabel = document.getElementById('targetLanguageLabel');

            // Update source language
            if (sourceLang) {
                sourceSelect.value = sourceLang;
                selectedSourceLanguage = sourceLang;

                // Add visual indicator with green checkmark
                if (sourceLabel) {
                    sourceLabel.innerHTML = `üåç Source Language: <span style="color: #10b981; font-weight: bold;">‚úì ${getLanguageName(sourceLang)} (Auto-detected)</span>`;
                }
            }

            // Update target language
            if (targetLang) {
                targetSelect.value = targetLang;
                selectedTargetLanguage = targetLang;

                // Add visual indicator with green checkmark
                if (targetLabel) {
                    targetLabel.innerHTML = `üéØ Target Language: <span style="color: #10b981; font-weight: bold;">‚úì ${getLanguageName(targetLang)} (Auto-detected)</span>`;
                }
            }

            // Reload voices with detected languages
            loadVoices();
        }

        // Get full language name from code
        function getLanguageName(code) {
            const languageNames = {
                'de': 'German',
                'en': 'English',
                'es': 'Spanish',
                'fr': 'French',
                'it': 'Italian',
                'pt': 'Portuguese',
                'ru': 'Russian',
                'ja': 'Japanese',
                'ko': 'Korean',
                'zh': 'Chinese',
                'ar': 'Arabic',
                'hi': 'Hindi',
                'nl': 'Dutch',
                'pl': 'Polish',
                'tr': 'Turkish',
                'sv': 'Swedish',
                'da': 'Danish',
                'no': 'Norwegian',
                'fi': 'Finnish'
            };
            return languageNames[code] || code;
        }

        // Legacy functions for compatibility
        function detectGerman(text) {
            return detectLanguageFromText(text) === 'de';
        }

        function detectEnglish(text) {
            return detectLanguageFromText(text) === 'en';
        }

        function isLikelyWord(text) {
            if (!text) return false;
            const trimmed = text.trim();
            // A word/short phrase is typically:
            // - 1-3 words OR
            // - Contains slashes (like "happy / sad / angry") but less than 8 words
            const wordCount = trimmed.split(/\s+/).length;
            const hasSlashes = /\//.test(trimmed);
            return wordCount <= 3 || (hasSlashes && wordCount <= 8);
        }

        function isLikelySentence(text) {
            if (!text) return false;
            const trimmed = text.trim();
            // A sentence is typically: longer text with sentence punctuation
            const wordCount = trimmed.split(/\s+/).length;
            const hasSentencePunctuation = /[.!?]/.test(trimmed);
            // Don't count slash-separated lists as sentences
            const hasSlashes = /\//.test(trimmed);
            return (wordCount > 8 || (wordCount > 3 && hasSentencePunctuation)) && !hasSlashes;
        }

        // Advanced per-row format detection
        function detectRowFormat(parts) {
            if (!parts || parts.length < 2) return null;

            // If manual column mapping is set, use it
            if (columnMapping && Object.keys(columnMapping).length > 0) {
                const result = {
                    source: '',
                    sourceExtended: '',
                    target: '',
                    targetExtended: '',
                    detail: ''
                };

                Object.keys(columnMapping).forEach(colKey => {
                    const colIndex = parseInt(colKey.replace('col', ''));
                    const colType = columnMapping[colKey];
                    const colValue = parts[colIndex] ? parts[colIndex].trim() : '';

                    if (colType === 'source') result.source = colValue;
                    else if (colType === 'sourceExtended') result.sourceExtended = colValue;
                    else if (colType === 'target') result.target = colValue;
                    else if (colType === 'targetExtended') result.targetExtended = colValue;
                });

                console.log('Using manual mapping:', result);
                return result;
            }

            // Universal auto-detection based on word length only (no language-specific detection)
            const columns = parts.map((part, idx) => {
                const trimmed = part.trim();
                return {
                    index: idx,
                    text: trimmed,
                    isLong: isLikelySentence(trimmed),
                    isShort: isLikelyWord(trimmed),
                    wordCount: trimmed.split(/\s+/).length
                };
            });

            let result = {
                source: '',
                sourceExtended: '',
                target: '',
                targetExtended: '',
                detail: ''
            };

            // Universal strategy: Use word length to determine role
            // Assumption: Shorter texts are main vocabulary, longer texts are examples

            // Sort columns by word count
            const sortedByLength = [...columns].sort((a, b) => a.wordCount - b.wordCount);

            // Identify short and long columns
            const shortColumns = columns.filter(c => c.isShort);
            const longColumns = columns.filter(c => c.isLong);

            if (parts.length === 2) {
                // Simple 2-column format: source, target
                result.source = parts[0].trim();
                result.target = parts[1].trim();
            } else if (parts.length === 3) {
                // 3-column format: could be source, sourceEx, target OR source, target, targetEx
                // Use lengths to determine
                if (shortColumns.length >= 2) {
                    // Two short columns - likely source and target words
                    result.source = shortColumns[0].text;
                    result.target = shortColumns[1].text;
                    // Third column is extended
                    const remaining = columns.find(c => c.index !== shortColumns[0].index && c.index !== shortColumns[1].index);
                    if (remaining) {
                        // Assign to sourceExtended or targetExtended based on position
                        if (remaining.index === 1) result.sourceExtended = remaining.text;
                        else result.targetExtended = remaining.text;
                    }
                } else {
                    // Fallback: first is source, second is extended, third is target
                    result.source = parts[0].trim();
                    result.sourceExtended = parts[1].trim();
                    result.target = parts[2].trim();
                }
            } else if (parts.length >= 4) {
                // 4+ column format: source, sourceEx, target, targetEx
                if (shortColumns.length >= 2) {
                    result.source = shortColumns[0].text;
                    result.target = shortColumns[1].text;

                    // Assign remaining as extended
                    const unused = columns.filter(c => c.index !== shortColumns[0].index && c.index !== shortColumns[1].index);
                    if (unused.length >= 1) result.sourceExtended = unused[0].text;
                    if (unused.length >= 2) result.targetExtended = unused[1].text;
                } else {
                    // Fallback: assign by position
                    result.source = parts[0].trim();
                    result.sourceExtended = parts[1].trim();
                    result.target = parts[2].trim();
                    result.targetExtended = parts[3].trim();
                }
            }

            console.log('Universal auto-detection result:', result);
            return result;
        }

        // Show format selector (3 options)
        function showFormatSelector(lines, separator) {
            // Show language selector FIRST (more prominent)
            document.getElementById('languageSelector').style.display = 'block';

            // Detect languages from CSV content
            const detectedLanguages = detectLanguagesFromCSV(rawFileData);
            console.log('üîç Detected languages:', detectedLanguages);

            // Update UI with detected languages
            if (detectedLanguages.source || detectedLanguages.target) {
                updateLanguageSelectorWithDetection(detectedLanguages.source, detectedLanguages.target);

                // Show success message
                const languageSelector = document.getElementById('languageSelector');
                const existingMessage = languageSelector.querySelector('.detection-message');
                if (!existingMessage) {
                    const message = document.createElement('div');
                    message.className = 'detection-message';
                    message.style.cssText = 'margin-top: 15px; padding: 12px; background: rgba(255,255,255,0.95); border-radius: 8px; font-size: 0.9em; color: #065f46; border: 2px solid #10b981; text-align: center; font-weight: 600;';
                    message.innerHTML = `‚úÖ <strong>Auto-detection complete!</strong> Languages have been detected and selected. You can change them above if needed.`;
                    languageSelector.appendChild(message);
                }
            }

            document.getElementById('formatSelector').style.display = 'block';
            document.getElementById('instructions').style.display = 'none';

            // Add event listeners to preset format buttons
            document.querySelectorAll('.format-preset-btn').forEach(btn => {
                btn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    const format = btn.getAttribute('data-format');
                    applyPredefinedFormat(format);
                });
            });
        }

        // Option 1: Predefined formats
        function selectPredefinedFormat() {
            // Just highlight - buttons already have click handlers
            console.log('Click a preset format button');
        }

        function applyPredefinedFormat(format) {
            console.log('Applying predefined format:', format);

            // Set column mapping based on format
            columnMapping = {};

            switch(format) {
                case '3col-standard': // Source, Source Example, Target
                    columnMapping = {
                        col0: 'source',
                        col1: 'sourceExtended',
                        col2: 'target'
                    };
                    break;
                case '3col-reverse': // Target, Target Example, Source
                    columnMapping = {
                        col0: 'target',
                        col1: 'targetExtended',
                        col2: 'source'
                    };
                    break;
                case '4col-full': // Source, Source Ex., Target, Target Ex.
                    columnMapping = {
                        col0: 'source',
                        col1: 'sourceExtended',
                        col2: 'target',
                        col3: 'targetExtended'
                    };
                    break;
                case '2col-simple': // Source, Target
                    columnMapping = {
                        col0: 'source',
                        col1: 'target'
                    };
                    break;
            }

            // Hide selector and reload with predefined mapping
            document.getElementById('formatSelector').style.display = 'none';
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Option 2: Manual mapping - Open modal immediately
        function selectManualMapping() {
            document.getElementById('formatSelector').style.display = 'none';
            const lines = rawFileData.split('\n').filter(line => line.trim() !== '');
            showColumnMapperModal(lines, detectedSeparator);
        }

        // Show column mapper in modal popup
        function showColumnMapperModal(lines, separator) {
            const table = document.getElementById('dataPreviewTable');

            // Get first 10 data rows (skip header if present)
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('german') || firstLine.includes('english') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            const previewRows = lines.slice(startIndex, Math.min(startIndex + 10, lines.length));
            const sampleData = previewRows.map(line => line.split(separator).map(col => col.trim()));
            const numColumns = sampleData[0].length;

            // Initialize column types (all unassigned initially)
            const columnTypes = new Array(numColumns).fill('unassigned');

            // Build table HTML
            let tableHTML = '<thead><tr>';

            // Create column headers with dropdown selectors
            for (let i = 0; i < numColumns; i++) {
                tableHTML += `
                    <th id="col-header-${i}" data-col-index="${i}" onclick="toggleColumnTypeSelector(${i})" style="position: relative; cursor: pointer;">
                        <div style="font-size: 1.2em; margin-bottom: 5px;">Column ${i + 1}</div>
                        <div class="column-type-selector" id="type-selector-${i}">
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'source')" style="color: #10b981;">
                                <span style="font-size: 1.5em;">üåç</span>
                                <span>Source Word<br><small style="font-weight: normal; opacity: 0.8;">Main vocab (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'sourceExtended')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">üìù</span>
                                <span>Source Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'target')" style="color: #3b82f6;">
                                <span style="font-size: 1.5em;">üéØ</span>
                                <span>Target Word<br><small style="font-weight: normal; opacity: 0.8;">Main translation (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'targetExtended')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">üìñ</span>
                                <span>Target Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'ignore')" style="color: #94a3b8;">
                                <span style="font-size: 1.5em;">üö´</span>
                                <span>Ignore Column<br><small style="font-weight: normal; opacity: 0.8;">Skip this data</small></span>
                            </div>
                        </div>
                    </th>
                `;
            }
            tableHTML += '</tr></thead><tbody>';

            // Add data rows
            sampleData.forEach((row, rowIndex) => {
                tableHTML += '<tr>';
                row.forEach((cell, colIndex) => {
                    const displayText = cell.length > 40 ? cell.substring(0, 40) + '...' : cell;
                    tableHTML += `<td title="${cell}">${displayText}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;

            // Store column types globally for later use
            window.currentColumnTypes = columnTypes;

            // Show the modal
            document.getElementById('columnMapperModal').style.display = 'flex';
        }

        // Close column mapper modal
        function closeColumnMapperModal() {
            document.getElementById('columnMapperModal').style.display = 'none';
            // Only show format selector again if user cancelled (not applied)
            if (!flashcards || flashcards.length === 0) {
                document.getElementById('formatSelector').style.display = 'block';
            }
        }

        // Option 3: Auto-detection
        function selectAutoDetection() {
            columnMapping = null; // Reset to auto-detect
            document.getElementById('formatSelector').style.display = 'none';
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Show column mapping interface with data preview table
        function showColumnMapper(lines, separator) {
            const columnMapper = document.getElementById('columnMapper');
            const table = document.getElementById('dataPreviewTable');

            // Get first 10 data rows (skip header if present)
            let startIndex = 0;
            const firstLine = lines[0].toLowerCase();
            if (firstLine.includes('german') || firstLine.includes('english') ||
                firstLine.includes('deutsch') || firstLine.includes('word') || firstLine.includes('voc')) {
                startIndex = 1;
            }

            const previewRows = lines.slice(startIndex, Math.min(startIndex + 10, lines.length));
            const sampleData = previewRows.map(line => line.split(separator).map(col => col.trim()));
            const numColumns = sampleData[0].length;

            // Initialize column types (all unassigned initially)
            const columnTypes = new Array(numColumns).fill('unassigned');

            // Build table HTML
            let tableHTML = '<thead><tr>';

            // Create column headers with dropdown selectors
            for (let i = 0; i < numColumns; i++) {
                tableHTML += `
                    <th id="col-header-${i}" data-col-index="${i}" onclick="toggleColumnTypeSelector(${i})" style="position: relative; cursor: pointer;">
                        <div style="font-size: 1.2em; margin-bottom: 5px;">Column ${i + 1}</div>
                        <div class="column-type-selector" id="type-selector-${i}">
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'source')" style="color: #10b981;">
                                <span style="font-size: 1.5em;">üåç</span>
                                <span>Source Word<br><small style="font-weight: normal; opacity: 0.8;">Main vocab (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'sourceExtended')" style="color: #f59e0b;">
                                <span style="font-size: 1.5em;">üìù</span>
                                <span>Source Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'target')" style="color: #3b82f6;">
                                <span style="font-size: 1.5em;">üéØ</span>
                                <span>Target Word<br><small style="font-weight: normal; opacity: 0.8;">Main translation (visible)</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'targetExtended')" style="color: #ec4899;">
                                <span style="font-size: 1.5em;">üìñ</span>
                                <span>Target Example<br><small style="font-weight: normal; opacity: 0.8;">Hidden until revealed</small></span>
                            </div>
                            <div class="type-option" onclick="event.stopPropagation(); setColumnType(${i}, 'ignore')" style="color: #94a3b8;">
                                <span style="font-size: 1.5em;">üö´</span>
                                <span>Ignore Column<br><small style="font-weight: normal; opacity: 0.8;">Skip this data</small></span>
                            </div>
                        </div>
                    </th>
                `;
            }
            tableHTML += '</tr></thead><tbody>';

            // Add data rows
            sampleData.forEach((row, rowIndex) => {
                tableHTML += '<tr>';
                row.forEach((cell, colIndex) => {
                    const displayText = cell.length > 40 ? cell.substring(0, 40) + '...' : cell;
                    tableHTML += `<td title="${cell}">${displayText}</td>`;
                });
                tableHTML += '</tr>';
            });

            tableHTML += '</tbody>';
            table.innerHTML = tableHTML;

            // Store column types globally for later use
            window.currentColumnTypes = columnTypes;

            // Show the mapper
            columnMapper.style.display = 'block';
            document.getElementById('instructions').style.display = 'none';
        }

        // Toggle column type selector - Show dropdown
        function toggleColumnTypeSelector(colIndex) {
            const selector = document.getElementById(`type-selector-${colIndex}`);
            if (!selector) return;

            // Close all other selectors
            document.querySelectorAll('.column-type-selector.active').forEach(s => {
                if (s !== selector) s.classList.remove('active');
            });

            // Toggle current selector - CSS handles positioning automatically
            selector.classList.add('active');
        }

        // Set column type
        function setColumnType(colIndex, type) {
            window.currentColumnTypes[colIndex] = type;

            const header = document.getElementById(`col-header-${colIndex}`);

            // Remove all type classes
            header.classList.remove('type-source', 'type-sourceExtended', 'type-target', 'type-targetExtended', 'type-ignore');

            // Add new type class
            if (type !== 'unassigned') {
                header.classList.add(`type-${type}`);
            }

            // Update header text and visual appearance
            const typeInfo = {
                'source': { icon: 'üåç', name: 'Source Word', desc: 'Main vocab (visible)' },
                'sourceExtended': { icon: 'üìù', name: 'Source Example', desc: 'Extended (hidden)' },
                'target': { icon: 'üéØ', name: 'Target Word', desc: 'Main translation (visible)' },
                'targetExtended': { icon: 'üìñ', name: 'Target Example', desc: 'Extended (hidden)' },
                'ignore': { icon: 'üö´', name: 'Ignored', desc: 'Will be skipped' }
            };

            const info = typeInfo[type];

            // Preserve the dropdown selector HTML
            const selectorHTML = header.querySelector('.column-type-selector').outerHTML;

            // Update header content while keeping the dropdown
            header.innerHTML = `
                <div style="font-size: 2em; margin-bottom: 8px;">${info.icon}</div>
                <div style="font-size: 1em; font-weight: 600;">${info.name}</div>
                <div style="font-size: 0.75em; font-weight: normal; margin-top: 5px; opacity: 0.9;">${info.desc}</div>
                ${selectorHTML}
            `;

            // Re-attach the onclick event
            header.onclick = () => toggleColumnTypeSelector(colIndex);

            // Close all dropdowns
            document.querySelectorAll('.column-type-selector').forEach(selector => {
                selector.classList.remove('active');
            });

            console.log('Column', colIndex, 'set to', type);
        }

        // Close dropdowns when clicking outside, and close mapper modal when clicking overlay
        document.addEventListener('click', (e) => {
            const columnMapperModal = document.getElementById('columnMapperModal');

            // Close mapper modal if clicking on overlay
            if (e.target === columnMapperModal) {
                closeColumnMapperModal();
            }

            // Close dropdowns if clicking outside column headers and dropdowns
            if (!e.target.closest('th') && !e.target.closest('.column-type-selector')) {
                document.querySelectorAll('.column-type-selector').forEach(selector => {
                    selector.classList.remove('active');
                });
            }
        });

        // Process file with manual column mapping
        function processWithManualMapping() {
            // Build column mapping from user selections in the table
            columnMapping = {};
            window.currentColumnTypes.forEach((type, index) => {
                if (type !== 'ignore' && type !== 'unassigned') {
                    columnMapping[`col${index}`] = type;
                }
            });

            console.log('Manual column mapping:', columnMapping);

            // Validate that at least source and target are set
            const hasSource = Object.values(columnMapping).includes('source');
            const hasTarget = Object.values(columnMapping).includes('target');

            if (!hasSource || !hasTarget) {
                alert('Please assign at least one Source Word column and one Target Word column!');
                return;
            }

            // Close modal and continue with parsing
            closeColumnMapperModal();

            // Re-parse with manual mapping enabled
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Use auto-detection (skip manual mapping)
        function useAutoDetection() {
            columnMapping = null; // Reset to auto-detect
            document.getElementById('columnMapper').style.display = 'none';

            // Re-parse with auto-detection
            const file = new File([rawFileData], currentFileName, { type: 'text/csv' });
            parseCSV(file, true);
        }

        // Detect CSV separator (comma, semicolon, tab, or pipe)
        function detectSeparator(text) {
            const lines = text.split('\n').filter(line => line.trim() !== '');
            if (lines.length === 0) return ',';

            const firstLine = lines[0];
            const separators = [',', ';', '\t', '|'];
            let bestSeparator = ',';
            let maxColumns = 0;

            for (const sep of separators) {
                const columns = firstLine.split(sep).length;
                if (columns > maxColumns && columns >= 2) {
                    maxColumns = columns;
                    bestSeparator = sep;
                }
            }

            return bestSeparator;
        }

        // Parse CSV file with smart format detection
        function parseCSV(file, useManualMapping = false) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const text = e.target.result;
                const lines = text.split('\n').filter(line => line.trim() !== '');

                currentFileName = file.name;
                rawFileData = text;

                // Detect separator automatically
                detectedSeparator = detectSeparator(text);
                console.log('Detected separator:', detectedSeparator === '\t' ? 'TAB' : detectedSeparator);

                // Show format selector on first load (unless explicitly using a method)
                if (!useManualMapping) {
                    showFormatSelector(lines, detectedSeparator);
                    return;
                }

                // Continue with actual parsing
                const savedProgress = loadProgress(currentFileName);

                // Check if first line is a header
                let startIndex = 0;
                const firstLine = lines[0].toLowerCase();
                if (firstLine.includes('german') || firstLine.includes('english') ||
                    firstLine.includes('deutsch') || firstLine.includes('word') ||
                    firstLine.includes('voc')) {
                    startIndex = 1; // Skip header row
                }

                flashcards = lines.slice(startIndex).map((line, index) => {
                    const parts = line.split(detectedSeparator).map(part => part.trim());

                    if (parts.length < 2) return null; // Need at least 2 columns

                    // Use new per-row format detection
                    const detected = detectRowFormat(parts);

                    if (!detected || !detected.source || !detected.target) {
                        // Fallback if detection fails
                        console.warn('Detection failed for row:', index, parts);
                        return null;
                    }

                    let source = detected.source;
                    let sourceExtended = detected.sourceExtended;
                    let target = detected.target;
                    let targetExtended = detected.targetExtended;
                    let detail = detected.detail;

                    // Check if we have saved progress for this card
                    const savedCard = savedProgress?.find(s => s.source === source && s.target === target);

                    const cardData = {
                        id: index,
                        source: source,
                        sourceExtended: sourceExtended,
                        target: target,
                        targetExtended: targetExtended,
                        detail: detail,
                        hasExtended: !!(sourceExtended || targetExtended),
                        learned: savedCard?.learned || false,
                        reviewDate: savedCard?.reviewDate || null,
                        repetitions: savedCard?.repetitions || 0,
                        easeFactor: savedCard?.easeFactor || 2.5,
                        interval: savedCard?.interval || 1
                    };

                    // Debug logging for first 3 cards
                    if (index < 3) {
                        console.log(`Card ${index} parsed:`, cardData);
                        console.log(`Card ${index} raw columns:`, {
                            col0: parts[0],
                            col1: parts[1],
                            col2: parts[2],
                            col3: parts[3]
                        });
                    }

                    return cardData;
                }).filter(card => card && card.source && card.target);

                if (flashcards.length > 0) {
                    const dueCount = flashcards.filter(isDueForReview).length;
                    const sepName = detectedSeparator === '\t' ? 'TAB' : detectedSeparator === ',' ? 'COMMA' : detectedSeparator === ';' ? 'SEMICOLON' : 'PIPE';
                    const extCount = flashcards.filter(card => card.hasExtended).length;
                    fileInfo.innerHTML = `<strong>üìÇ ${currentFileName}</strong><br>‚úÖ Loaded ${flashcards.length} cards (${dueCount} due for review) | Separator: ${sepName} | Extended: ${extCount}`;
                    currentIndex = 0;
                    filteredCards = [...flashcards];

                    // Load file category
                    if (fileCategories[currentFileName]) {
                        currentFileCategory = fileCategories[currentFileName];
                    } else {
                        currentFileCategory = { category: 'Default', subcategory: '' };
                        fileCategories[currentFileName] = currentFileCategory;
                        saveCategories();
                    }

                    updateStats();
                    showFlashcard();
                    updateCurrentFileDisplay();

                    // Show main UI elements
                    flashcardContainer.style.display = 'block';
                    navigation.style.display = 'flex';
                    stats.style.display = 'block';
                    document.getElementById('practiceModeBtn').style.display = 'block';

                    // Show new UI elements
                    document.getElementById('quickActions').style.display = 'grid';
                    document.getElementById('settingsToggleBtn').style.display = 'flex';
                    document.getElementById('clearFileBtn').style.display = 'inline-block';

                    // Show language selector after file is loaded
                    document.getElementById('languageSelector').style.display = 'block';

                    // Hide instructions after successful load
                    document.getElementById('instructions').style.display = 'none';
                } else {
                    fileInfo.textContent = '‚ùå No valid flashcards found in file';
                    document.getElementById('clearFileBtn').style.display = 'none';
                }
            };
            reader.readAsText(file);
        }

        // Update statistics
        function updateStats() {
            const learned = flashcards.filter(card => card.learned).length;
            const total = flashcards.length;
            const remaining = total - learned;

            learnedCount.textContent = learned;
            remainingCount.textContent = remaining;
            totalCount.textContent = total;

            saveProgress(); // Save whenever stats update
        }

        // Pronounce source word
        function pronounceSource(text) {
            if (!synth) return;

            synth.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            if (sourceVoice) {
                utterance.voice = sourceVoice;
                utterance.lang = sourceVoice.lang;
            }
            utterance.rate = speechRate; // User-configurable rate
            utterance.pitch = speechPitch; // User-configurable pitch
            synth.speak(utterance);
        }

        // Pronounce target word
        function pronounceTarget(text) {
            if (!synth) return;

            synth.cancel(); // Stop any ongoing speech

            const utterance = new SpeechSynthesisUtterance(text);
            if (targetVoice) {
                utterance.voice = targetVoice;
                utterance.lang = targetVoice.lang;
            }
            utterance.rate = speechRate; // User-configurable rate
            utterance.pitch = speechPitch; // User-configurable pitch
            synth.speak(utterance);
        }

        // Get active card list
        function getActiveCards() {
            return showOnlyUnlearned
                ? flashcards.filter(card => !card.learned)
                : flashcards;
        }

        // Show current flashcard
        function showFlashcard() {
            filteredCards = getActiveCards();

            if (filteredCards.length === 0) {
                sourceWord.textContent = 'No cards available';
                targetWord.textContent = 'Load a CSV file or adjust filter';
                detailBack.style.display = 'none';
                learnedBadge.style.display = 'none';
                return;
            }

            // Adjust index if out of bounds
            if (currentIndex >= filteredCards.length) {
                currentIndex = filteredCards.length - 1;
            }
            if (currentIndex < 0) {
                currentIndex = 0;
            }

            const card = filteredCards[currentIndex];

            // Debug logging
            console.log('Displaying card:', {
                source: card.source,
                sourceExtended: card.sourceExtended,
                target: card.target,
                targetExtended: card.targetExtended
            });

            sourceWord.textContent = card.source;
            targetWord.textContent = card.target;

            // Show detail and extended content indicators (only target-related content)
            let detailText = '';
            if (card.targetExtended) {
                detailText += `üìù ${card.targetExtended}\n`;
            }
            if (card.detail) {
                detailText += card.detail;
            }

            if (detailText) {
                detailBack.textContent = detailText;
                detailBack.style.display = 'block';
                detailBack.style.whiteSpace = 'pre-line'; // Preserve line breaks
            } else {
                detailBack.style.display = 'none';
            }

            // Show review date info
            if (card.reviewDate && card.repetitions > 0) {
                const reviewDate = new Date(card.reviewDate);
                const daysUntil = Math.ceil((reviewDate - new Date()) / (1000 * 60 * 60 * 24));
                if (daysUntil > 0) {
                    reviewInfo.textContent = `Next review in ${daysUntil} day${daysUntil > 1 ? 's' : ''}`;
                } else if (daysUntil === 0) {
                    reviewInfo.textContent = 'Review due today';
                } else {
                    reviewInfo.textContent = 'Review overdue';
                }
                reviewInfo.style.display = 'block';
            } else {
                reviewInfo.style.display = 'none';
            }

            // Show/hide learned badge
            if (card.learned) {
                learnedBadge.style.display = 'block';
                learnedBtn.textContent = '‚úó Unmark Learned';
            } else {
                learnedBadge.style.display = 'none';
                learnedBtn.textContent = '‚úì Mark as Learned';
            }

            progress.textContent = `${currentIndex + 1} / ${filteredCards.length}`;

            // Handle target section visibility
            if (alwaysShowMeanings) {
                targetSection.classList.add('revealed');
                revealBtn.style.display = 'none';
            } else {
                targetSection.classList.remove('revealed');
                revealBtn.style.display = 'block';
                revealBtn.textContent = 'üëÅ Show Translation';
            }

            // Update button states
            prevBtn.disabled = currentIndex === 0;
            nextBtn.disabled = currentIndex === filteredCards.length - 1;
        }

        // Reveal target meaning
        function revealTarget() {
            targetSection.classList.add('revealed');
            revealBtn.textContent = '‚úì Meaning Shown';
            revealBtn.style.opacity = '0.7';
        }

        // Auto-play functions
        function startAutoPlay() {
            if (filteredCards.length === 0) return;

            isAutoPlaying = true;
            autoplayBtn.textContent = '‚è∏ Stop';
            autoplayBtn.classList.add('playing');

            // Auto-open settings menu and expand auto-play accordion
            document.getElementById('settingsMenu').style.display = 'block';
            document.getElementById('settingsToggleBtn').classList.add('active');

            // Open Auto-Play and Advanced accordions
            const accordions = document.querySelectorAll('.accordion-header');
            accordions.forEach(header => {
                const text = header.textContent;
                if (text.includes('Auto-Play') || text.includes('Advanced Features')) {
                    header.classList.add('active');
                    header.nextElementSibling.classList.add('active');
                }
            });

            // Start session stats
            startSessionStats();

            // Start timers if enabled
            if (studyTimerEnabled) {
                startStudyTimer();
            }
            if (sleepTimerEnabled) {
                startSleepTimer();
            }

            // Start recording if enabled
            const recordCheckbox = document.getElementById('recordSession');
            if (recordCheckbox && recordCheckbox.checked) {
                startRecording();
            }

            // Start from current card
            currentRepeat = 0;
            playCurrentCard();
        }

        function stopAutoPlay(reason = 'manual', autoComplete = false) {
            isAutoPlaying = false;
            autoplayBtn.textContent = '‚ñ∂ Auto-Play';
            autoplayBtn.classList.remove('playing');

            // Clear any pending timeouts
            if (autoplayTimeout) {
                clearTimeout(autoplayTimeout);
                autoplayTimeout = null;
            }

            // Stop any ongoing speech
            if (synth) {
                synth.cancel();
            }

            // Check if recording was enabled (either actively recording or has recorded data)
            const recordCheckbox = document.getElementById('recordSession');
            const wasRecordingEnabled = recordCheckbox && recordCheckbox.checked;
            const hasRecordingData = isRecording || (mediaRecorder && mediaRecorder.state !== 'inactive') || recordedChunks.length > 0;

            // Handle recording based on stop reason
            if (wasRecordingEnabled && hasRecordingData) {
                if (reason === 'manual' && !autoComplete) {
                    // Manual stop - ask user if they want to save recording
                    const saveRecording = confirm('Do you want to save the recorded audio?\n\nClick OK to save, Cancel to discard.');
                    if (saveRecording) {
                        stopRecording();
                        alert('‚úì Recording saved! You can download or play it from the Auto-Play Settings.');
                    } else {
                        // Discard recording
                        if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                            mediaRecorder.stop();
                            mediaRecorder.stream.getTracks().forEach(track => track.stop());
                        }
                        if (recordingTimerInterval) {
                            clearInterval(recordingTimerInterval);
                            recordingTimerInterval = null;
                        }
                        document.getElementById('recordingControls').style.display = 'none';
                        isRecording = false;
                        recordedChunks = [];
                        alert('Recording discarded.');
                    }
                } else {
                    // Automatic end or timer end - always save recording
                    stopRecording();
                    if (reason === 'complete') {
                        alert('‚úÖ Auto-play completed! Recording has been saved automatically.\n\nYou can download or play it from the Auto-Play Settings.');
                    }
                }
            }

            // Stop timers
            stopAllTimers();

            // Show appropriate message (only if recording wasn't already handled)
            const wasRecording = recordedAudioBlob !== null;
            if (reason === 'timer') {
                if (wasRecording) {
                    alert('‚è∞ Time\'s up! Auto-play stopped.\nRecording has been saved automatically.');
                } else {
                    alert('‚è∞ Time\'s up! Auto-play stopped.');
                }
            } else if (reason === 'sleep') {
                if (wasRecording) {
                    alert('üìö Sleep timer complete. Good night!\nRecording has been saved automatically.');
                } else {
                    alert('üìö Sleep timer complete. Good night!');
                }
            } else if (reason === 'complete' && !wasRecording) {
                alert('‚úÖ Auto-play completed! Reached the end of cards.');
            }
        }

        function playCurrentCard() {
            if (!isAutoPlaying || filteredCards.length === 0) return;

            const card = filteredCards[currentIndex];

            // Always reveal target in auto-play mode
            if (!alwaysShowMeanings) {
                revealTarget();
            }

            // Increment cards reviewed (only once per card, not per repeat)
            if (currentRepeat === 0) {
                cardsReviewedCount++;
                updateSessionStats();
            }

            // Determine what to pronounce
            const sourceText = readExtendedContent && card.sourceExtended ? card.sourceExtended : card.source;
            const targetText = readExtendedContent && card.targetExtended ? card.targetExtended : card.target;

            // Step 1: Pronounce source (word or extended)
            pronounceSource(sourceText);

            // Step 2: Wait, then pronounce target if enabled
            if (autoplayEnglishEnabled) {
                autoplayTimeout = setTimeout(() => {
                    if (!isAutoPlaying) return;
                    pronounceTarget(targetText);

                    // Step 3: Wait, then move to next card or repeat
                    autoplayTimeout = setTimeout(() => {
                        if (!isAutoPlaying) return;
                        handleCardCompletion();
                    }, delayBeforeNext);
                }, delayBetweenLangs);
            } else {
                // If target not enabled, just wait and move to next or repeat
                autoplayTimeout = setTimeout(() => {
                    if (!isAutoPlaying) return;
                    handleCardCompletion();
                }, delayBeforeNext);
            }
        }

        function handleCardCompletion() {
            if (!isAutoPlaying) return;

            // Check if repeat mode is enabled
            if (repeatModeEnabled && currentRepeat < repeatCount - 1) {
                currentRepeat++;
                playCurrentCard(); // Repeat the same card
            } else {
                currentRepeat = 0; // Reset repeat counter
                moveToNextCardInAutoPlay();
            }
        }

        function moveToNextCardInAutoPlay() {
            if (!isAutoPlaying) return;

            // Move to next card
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showFlashcard();
                playCurrentCard();
            } else {
                // Reached end
                if (loopModeEnabled) {
                    // Loop back to beginning
                    currentIndex = 0;
                    showFlashcard();
                    playCurrentCard();
                } else {
                    // Stop auto-play with 'complete' reason to auto-save recording
                    stopAutoPlay('complete', true);
                }
            }
        }

        // Timer functions
        function startStudyTimer() {
            const duration = parseInt(document.getElementById('studyDuration').value);
            timerEndTime = Date.now() + (duration * 60 * 1000);
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                updateTimerDisplay();
                if (Date.now() >= timerEndTime) {
                    stopAutoPlay('timer', true); // Auto-save recording
                }
            }, 1000);
        }

        function startSleepTimer() {
            const duration = parseInt(document.getElementById('sleepDuration').value);
            timerEndTime = Date.now() + (duration * 60 * 1000);
            document.getElementById('timerDisplay').style.display = 'block';
            updateTimerDisplay();
            timerInterval = setInterval(() => {
                updateTimerDisplay();
                if (Date.now() >= timerEndTime) {
                    stopAutoPlay('sleep', true); // Auto-save recording
                }
            }, 1000);
        }

        function updateTimerDisplay() {
            if (!timerEndTime) return;
            const remaining = Math.max(0, timerEndTime - Date.now());
            const minutes = Math.floor(remaining / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            document.getElementById('timerText').textContent =
                `‚è±Ô∏è Time Remaining: ${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function stopAllTimers() {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
            if (statsInterval) {
                clearInterval(statsInterval);
                statsInterval = null;
            }
            timerEndTime = null;
            document.getElementById('timerDisplay').style.display = 'none';
        }

        // Session stats functions
        function startSessionStats() {
            sessionStartTime = Date.now();
            cardsReviewedCount = 0;
            document.getElementById('sessionStats').style.display = 'block';
            document.getElementById('sessionStart').textContent = new Date().toLocaleTimeString();
            updateSessionStats();
            statsInterval = setInterval(updateSessionStats, 1000);
        }

        function updateSessionStats() {
            if (!sessionStartTime) return;

            const elapsed = Date.now() - sessionStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('cardsReviewed').textContent = cardsReviewedCount;
            document.getElementById('timeStudying').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;

            const cardsPerMin = minutes > 0 ? (cardsReviewedCount / minutes).toFixed(1) : '0.0';
            document.getElementById('cardsPerMinute').textContent = cardsPerMin;
        }

        // Recording functions
        async function startRecording() {
            try {
                // Request permission to capture tab audio
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true, // Required for tab capture
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });

                // Stop video track as we only need audio
                const videoTrack = stream.getVideoTracks()[0];
                if (videoTrack) videoTrack.stop();

                recordedChunks = [];
                mediaRecorder = new MediaRecorder(stream);

                mediaRecorder.ondataavailable = (event) => {
                    if (event.data.size > 0) {
                        recordedChunks.push(event.data);
                    }
                };

                mediaRecorder.onstop = () => {
                    recordedAudioBlob = new Blob(recordedChunks, { type: 'audio/webm' });
                    const audioUrl = URL.createObjectURL(recordedAudioBlob);
                    document.getElementById('recordedAudio').src = audioUrl;
                    document.getElementById('recordedAudioSection').style.display = 'block';
                    isRecording = false;
                };

                mediaRecorder.start();
                isRecording = true;
                recordingStartTime = Date.now();

                // Show recording controls
                document.getElementById('recordingControls').style.display = 'block';

                // Start recording timer
                recordingTimerInterval = setInterval(updateRecordingTimer, 1000);
            } catch (err) {
                console.error('Error starting recording:', err);
                alert('Unable to start recording. Please make sure you grant permission to capture tab audio.');
                isRecording = false;
            }
        }

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state !== 'inactive') {
                mediaRecorder.stop();

                // Stop all tracks
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }

            if (recordingTimerInterval) {
                clearInterval(recordingTimerInterval);
                recordingTimerInterval = null;
            }

            document.getElementById('recordingControls').style.display = 'none';
        }

        function updateRecordingTimer() {
            if (!recordingStartTime) return;

            const elapsed = Date.now() - recordingStartTime;
            const minutes = Math.floor(elapsed / 60000);
            const seconds = Math.floor((elapsed % 60000) / 1000);

            document.getElementById('recordingTime').textContent =
                `${minutes}:${seconds.toString().padStart(2, '0')}`;
        }

        function downloadRecording() {
            if (!recordedAudioBlob) return;

            const url = URL.createObjectURL(recordedAudioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `flashcard-session-${new Date().toISOString().slice(0,19).replace(/:/g,'-')}.webm`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function playRecording() {
            const audio = document.getElementById('recordedAudio');
            audio.style.display = 'block';
            audio.play();
        }

        // Focus Mode functions
        function enterFocusMode() {
            document.getElementById('focusMode').style.display = 'flex';
            document.body.style.overflow = 'hidden';
        }

        function exitFocusMode() {
            document.getElementById('focusMode').style.display = 'none';
            document.body.style.overflow = 'auto';
        }

        // Audio pronunciation - Source
        audioBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (filteredCards.length > 0) {
                const card = filteredCards[currentIndex];
                pronounceSource(card.source);
            }
        });

        // Audio pronunciation - Target
        audioBtnTarget.addEventListener('click', (e) => {
            e.stopPropagation();
            if (filteredCards.length > 0) {
                const card = filteredCards[currentIndex];
                pronounceTarget(card.target);
            }
        });

        // Reveal button click
        revealBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            revealTarget();
        });

        // Always show meanings checkbox
        alwaysShowMeaningsCheckbox.addEventListener('change', (e) => {
            alwaysShowMeanings = e.target.checked;
            showFlashcard(); // Refresh current card
        });

        // Read extended content checkbox
        document.getElementById('readExtendedContent').addEventListener('change', (e) => {
            readExtendedContent = e.target.checked;
        });

        // Auto-play button
        autoplayBtn.addEventListener('click', () => {
            if (isAutoPlaying) {
                stopAutoPlay();
            } else {
                startAutoPlay();
            }
        });

        // Auto-play English checkbox
        autoplayEnglishCheckbox.addEventListener('change', (e) => {
            autoplayEnglishEnabled = e.target.checked;
        });

        // Delay sliders
        delayBetweenSlider.addEventListener('input', (e) => {
            delayBetweenLangs = parseInt(e.target.value);
            delayBetweenValue.textContent = (delayBetweenLangs / 1000).toFixed(1) + 's';
        });

        delayNextSlider.addEventListener('input', (e) => {
            delayBeforeNext = parseInt(e.target.value);
            delayNextValue.textContent = (delayBeforeNext / 1000).toFixed(1) + 's';
        });

        // Voice selection handlers
        document.getElementById('sourceVoiceSelect').addEventListener('change', (e) => {
            const sortedVoices = [...allVoices].sort((a, b) => {
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                return a.lang.localeCompare(b.lang);
            });
            sourceVoice = sortedVoices[parseInt(e.target.value)];
            updateVoiceInfo('source', sourceVoice);
            console.log('Source voice changed to:', sourceVoice.name);
        });

        document.getElementById('targetVoiceSelect').addEventListener('change', (e) => {
            const sortedVoices = [...allVoices].sort((a, b) => {
                const aIsGoogle = a.name.toLowerCase().includes('google');
                const bIsGoogle = b.name.toLowerCase().includes('google');
                if (aIsGoogle && !bIsGoogle) return -1;
                if (!aIsGoogle && bIsGoogle) return 1;
                return a.lang.localeCompare(b.lang);
            });
            targetVoice = sortedVoices[parseInt(e.target.value)];
            updateVoiceInfo('target', targetVoice);
            console.log('Target voice changed to:', targetVoice.name);
        });

        // Speech rate handler
        document.getElementById('speechRate').addEventListener('input', (e) => {
            speechRate = parseFloat(e.target.value);
            document.getElementById('speechRateValue').textContent = speechRate.toFixed(1) + 'x';
        });

        // Pitch handler
        document.getElementById('speechPitch').addEventListener('input', (e) => {
            speechPitch = parseFloat(e.target.value);
            document.getElementById('speechPitchValue').textContent = speechPitch.toFixed(1);
        });

        // Language selector handlers
        document.getElementById('sourceLanguageSelect').addEventListener('change', (e) => {
            selectedSourceLanguage = e.target.value;
            const sourceLabel = document.getElementById('sourceLanguageLabel');

            if (selectedSourceLanguage) {
                console.log('Source language manually changed to:', selectedSourceLanguage);
                // Update label to show manual selection
                if (sourceLabel) {
                    sourceLabel.innerHTML = `üåç Source Language: <span style="color: #3b82f6; font-weight: bold;">üìù ${getLanguageName(selectedSourceLanguage)} (Manually Selected)</span>`;
                }
            } else {
                console.log('Source language changed to: Auto-detect');
                if (sourceLabel) {
                    sourceLabel.innerHTML = `üåç Source Language (Learning From):`;
                }
            }

            // Reload voices with new language selection
            loadVoices();
        });

        document.getElementById('targetLanguageSelect').addEventListener('change', (e) => {
            selectedTargetLanguage = e.target.value;
            const targetLabel = document.getElementById('targetLanguageLabel');

            if (selectedTargetLanguage) {
                console.log('Target language manually changed to:', selectedTargetLanguage);
                // Update label to show manual selection
                if (targetLabel) {
                    targetLabel.innerHTML = `üéØ Target Language: <span style="color: #3b82f6; font-weight: bold;">üìù ${getLanguageName(selectedTargetLanguage)} (Manually Selected)</span>`;
                }
            } else {
                console.log('Target language changed to: Auto-detect');
                if (targetLabel) {
                    targetLabel.innerHTML = `üéØ Target Language (Learning To):`;
                }
            }

            // Reload voices with new language selection
            loadVoices();
        });

        // Advanced features event listeners
        document.getElementById('loopMode').addEventListener('change', (e) => {
            loopModeEnabled = e.target.checked;
        });

        document.getElementById('repeatMode').addEventListener('change', (e) => {
            repeatModeEnabled = e.target.checked;
        });

        document.getElementById('repeatCount').addEventListener('change', (e) => {
            repeatCount = parseInt(e.target.value);
        });

        document.getElementById('studyTimer').addEventListener('change', (e) => {
            studyTimerEnabled = e.target.checked;
            if (!e.target.checked && timerInterval) {
                stopAllTimers();
            }
        });

        document.getElementById('sleepTimer').addEventListener('change', (e) => {
            sleepTimerEnabled = e.target.checked;
            if (!e.target.checked && timerInterval) {
                stopAllTimers();
            }
        });

        // Accordion toggle function
        function toggleAccordion(header) {
            const content = header.nextElementSibling;
            const wasActive = header.classList.contains('active');

            // Close all accordions first (optional - remove if you want multiple open)
            // document.querySelectorAll('.accordion-header').forEach(h => {
            //     h.classList.remove('active');
            //     h.nextElementSibling.classList.remove('active');
            // });

            // Toggle current accordion
            if (wasActive) {
                header.classList.remove('active');
                content.classList.remove('active');
            } else {
                header.classList.add('active');
                content.classList.add('active');

                // Auto-scroll to make the expanded section visible
                setTimeout(() => {
                    const settingsMenu = document.getElementById('settingsMenu');
                    const headerRect = header.getBoundingClientRect();
                    const menuRect = settingsMenu.getBoundingClientRect();

                    // Check if header is above the visible area
                    if (headerRect.top < menuRect.top) {
                        header.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 100);
            }
        }

        // Settings menu toggle
        document.getElementById('settingsToggleBtn').addEventListener('click', function() {
            const menu = document.getElementById('settingsMenu');
            const isVisible = menu.style.display === 'block';

            if (isVisible) {
                menu.style.display = 'none';
                this.classList.remove('active');
            } else {
                menu.style.display = 'block';
                this.classList.add('active');
            }
        });

        // Category Management toggle
        document.getElementById('categoryMgmtToggleBtn').addEventListener('click', function() {
            const section = document.getElementById('categoryManagerSection');
            const isVisible = section.style.display === 'block';

            if (isVisible) {
                section.style.display = 'none';
                this.classList.remove('active');
            } else {
                section.style.display = 'block';
                this.classList.add('active');
            }
        });

        // Focus Mode button
        document.getElementById('focusModeBtn').addEventListener('click', () => {
            enterFocusMode();
            // Clone the current flashcard to focus mode
            const mainCard = document.getElementById('flashcard');
            const focusCard = document.getElementById('focusFlashcard');
            focusCard.innerHTML = mainCard.innerHTML;
        });

        // Navigation
        prevBtn.addEventListener('click', () => {
            stopAutoPlay(); // Stop auto-play on manual navigation
            if (currentIndex > 0) {
                currentIndex--;
                showFlashcard();
            }
        });

        nextBtn.addEventListener('click', () => {
            stopAutoPlay(); // Stop auto-play on manual navigation
            if (currentIndex < filteredCards.length - 1) {
                currentIndex++;
                showFlashcard();
            }
        });

        // Shuffle cards
        shuffleBtn.addEventListener('click', () => {
            for (let i = flashcards.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [flashcards[i], flashcards[j]] = [flashcards[j], flashcards[i]];
            }
            currentIndex = 0;
            showFlashcard();
        });

        // Mark as learned/unlearned
        learnedBtn.addEventListener('click', () => {
            if (filteredCards.length === 0) return;

            // First reveal the English meaning if not visible
            if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                revealEnglish();
                // Give user a moment to see the meaning before marking
                setTimeout(() => {
                    markCardAsLearned();
                }, 300);
            } else {
                markCardAsLearned();
            }
        });

        function markCardAsLearned() {
            const card = filteredCards[currentIndex];

            if (!card.learned) {
                // Mark as learned and apply spaced repetition
                // Quality 4 = good recall (default when marking as learned)
                const reviewData = calculateNextReview(card, 4);
                card.learned = true;
                card.repetitions = reviewData.repetitions;
                card.easeFactor = reviewData.easeFactor;
                card.interval = reviewData.interval;
                card.reviewDate = reviewData.reviewDate;
            } else {
                // Unmark as learned and reset spaced repetition
                card.learned = false;
                card.repetitions = 0;
                card.interval = 1;
                card.reviewDate = null;
            }

            updateStats();
            showFlashcard();

            // Auto-advance to next unlearned card if in "show only unlearned" mode
            if (showOnlyUnlearned && card.learned) {
                if (filteredCards.length > 0) {
                    showFlashcard();
                }
            }
        }

        // Reset all progress
        resetBtn.addEventListener('click', () => {
            if (confirm('Reset all progress? This will unmark all learned cards and clear review schedules.')) {
                flashcards.forEach(card => {
                    card.learned = false;
                    card.repetitions = 0;
                    card.interval = 1;
                    card.reviewDate = null;
                });
                updateStats();
                showFlashcard();
            }
        });

        // Toggle show only unlearned
        showLearnedBtn.addEventListener('click', () => {
            showOnlyUnlearned = !showOnlyUnlearned;

            if (showOnlyUnlearned) {
                showLearnedBtn.textContent = 'üëÅ Show All Cards';
                showLearnedBtn.classList.add('active');
            } else {
                showLearnedBtn.textContent = 'üëÅ Show Only Unlearned';
                showLearnedBtn.classList.remove('active');
            }

            currentIndex = 0;
            showFlashcard();
        });

        // Remap columns button - show format selector again
        document.getElementById('remapColumnsBtn').addEventListener('click', () => {
            if (!rawFileData) {
                alert('Please load a file first!');
                return;
            }
            const lines = rawFileData.split('\n').filter(line => line.trim() !== '');
            showFormatSelector(lines, detectedSeparator);
        });

        // Recording event listeners
        document.getElementById('stopRecordingBtn').addEventListener('click', () => {
            stopRecording();
        });

        document.getElementById('downloadRecordingBtn').addEventListener('click', () => {
            downloadRecording();
        });

        document.getElementById('playRecordingBtn').addEventListener('click', () => {
            playRecording();
        });

        // Keyboard navigation
        document.addEventListener('keydown', (e) => {
            if (flashcards.length === 0) return;

            switch(e.key) {
                case 'ArrowLeft':
                    stopAutoPlay(); // Stop auto-play on manual navigation
                    if (currentIndex > 0) {
                        currentIndex--;
                        showFlashcard();
                    }
                    break;
                case 'ArrowRight':
                    stopAutoPlay(); // Stop auto-play on manual navigation
                    if (currentIndex < filteredCards.length - 1) {
                        currentIndex++;
                        showFlashcard();
                    }
                    break;
                case ' ':
                case 'Enter':
                    e.preventDefault();
                    if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                        revealEnglish();
                    }
                    break;
                case 'l':
                case 'L':
                    // Quick keyboard shortcut for marking as learned
                    if (filteredCards.length > 0) {
                        // First reveal the English meaning if not visible
                        if (!alwaysShowMeanings && !englishSection.classList.contains('revealed')) {
                            revealEnglish();
                            setTimeout(() => {
                                markCardAsLearned();
                            }, 300);
                        } else {
                            markCardAsLearned();
                        }
                    }
                    break;
                case 'p':
                case 'P':
                    // Quick keyboard shortcut for German pronunciation
                    if (filteredCards.length > 0) {
                        const card = filteredCards[currentIndex];
                        pronounceGerman(card.german);
                    }
                    break;
                case 'e':
                case 'E':
                    // Quick keyboard shortcut for English pronunciation
                    if (filteredCards.length > 0) {
                        const card = filteredCards[currentIndex];
                        pronounceEnglish(card.english);
                    }
                    break;
            }
        });

        // ============================================
        // PRACTICE MODE FUNCTIONALITY
        // ============================================
        let isPracticeMode = false;

        function togglePracticeMode() {
            isPracticeMode = !isPracticeMode;
            const body = document.body;
            const btn = document.getElementById('practiceModeBtn');

            if (isPracticeMode) {
                // Enter practice mode
                body.classList.add('practice-mode');
                btn.classList.add('active');
                btn.textContent = '‚èπÔ∏è Stop Practice Mode';

                // Scroll to flashcard and center it
                const flashcardContainer = document.getElementById('flashcardContainer');
                if (flashcardContainer) {
                    setTimeout(() => {
                        flashcardContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }, 100);
                }

                // Auto-hide target section to start fresh
                const targetSection = document.getElementById('targetSection');
                if (targetSection && targetSection.classList.contains('revealed')) {
                    targetSection.classList.remove('revealed');
                }
            } else {
                // Exit practice mode
                body.classList.remove('practice-mode');
                btn.classList.remove('active');
                btn.textContent = 'üéØ Start Practice Mode - Focus Only on Flashcards';

                // Scroll back to top smoothly
                window.scrollTo({ top: 0, behavior: 'smooth' });
            }
        }

        // Add keyboard shortcut for practice mode (Ctrl+P or Cmd+P)
        document.addEventListener('keydown', (e) => {
            if ((e.ctrlKey || e.metaKey) && e.key === 'p') {
                e.preventDefault();
                if (flashcards.length > 0) {
                    togglePracticeMode();
                }
            }
        });

        // ============================================
        // SESSION STATS COLLAPSE/EXPAND FUNCTIONALITY
        // ============================================
        function toggleSessionStats() {
            const content = document.getElementById('sessionStatsContent');
            const toggle = document.getElementById('sessionStatsToggle');

            if (content.classList.contains('collapsed')) {
                // Expand
                content.classList.remove('collapsed');
                toggle.classList.remove('collapsed');
                toggle.textContent = '‚ñº';
            } else {
                // Collapse
                content.classList.add('collapsed');
                toggle.classList.add('collapsed');
                toggle.textContent = '‚ñ∂';
            }
        }

        // Initialize app on page load
        window.addEventListener('DOMContentLoaded', function() {
            checkExistingLogin();
        });
    </script>

    <!-- Focus Mode Overlay -->
    <div class="focus-mode" id="focusMode">
        <button class="focus-exit-btn" onclick="exitFocusMode()">‚úï Exit Focus Mode</button>
        <div class="flashcard-container">
            <div class="flashcard" id="focusFlashcard">
                <!-- Will be cloned from main flashcard -->
            </div>
        </div>
    </div>

</body>
</html>
